<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Hardi Bhatt's Website | Code</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="css/coin-slider.css" />
<link rel="stylesheet" type="text/css" href="shadowbox/shadowbox.css">
<script type="text/javascript" src="js/cufon-yui.js"></script>
<script type="text/javascript" src="js/droid_sans_400-droid_sans_700.font.js"></script>
<script type="text/javascript" src="js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="js/script.js"></script>
<script type="text/javascript" src="js/coin-slider.min.js"></script>
<script type="text/javascript" src="js/utils.js"></script>
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="shadowbox/shadowbox.js"></script>
<script type="text/javascript">
Shadowbox.init({
    handleOversize: "drag",
    modal: true
});

$(document).ready(function(){
	
	$(".toggle_container").hide();

	$("h4.trigger").toggle(function(){
		$(this).addClass("active"); 
		}, function () {
		$(this).removeClass("active");
	});
	
	$("h4.trigger").click(function(){
		$(this).next(".toggle_container").slideToggle("slow,");
	});

});

	SyntaxHighlighter.config.clipboardSwf = 'js/clipboard.swf';
	SyntaxHighlighter.all();
</script>
</head>
<body>
<div class="main">
  <div class="header">
    <div class="header_resize">
      <div class="menu_nav">
         <ul>
          <li><a href="index.html"><span>Home Page</span></a></li>
          <li class="active"><a href="myArchive.html"><span>My Work</span></a></li>
          <li><a href="myResume.html"><span>My Resume</span></a></li>
          <li><a href="aboutMe.html"><span>About Me</span></a></li>
          <li><a href="myContact.html"><span>Contact Me</span></a></li>
        </ul>
      </div>
      <div class="logo">
        <h1><a href="index.html"><span>Hardi Bhatt</span> <small>A Creative Programmer</small></a></h1>
      </div>
      <div class="clr"></div>
      <div class="slider">
         <div id="coin-slider"> <a href="#"><img src="images/slide1.jpg" width="1500" height="327" alt="" /> </a> <a href="#"><img src="images/slide2.jpg" width="1500" height="327" alt="" /> </a> <a href="#"><img src="images/slide3.jpg" width="1500" height="327" alt="" /> </a> <a href="#"><img src="images/slide4.jpg" width="1500" height="327" alt="" /> </a> </div>
        <div class="clr"></div>
      </div>
      <div class="clr"></div>
    </div>
  </div>
  <div class="content">
    <div class="content_resize">
      <div class="mainbar">
		<div class="article">
          <h2><span>Advanced Computer Graphics</span></h2>
          <div class="clr"></div>
          <p>
			<div class="panelcollapsed">
			  <h3>Ray Tracer Algorithm</h3>
			  <div class="panelcontent">
				<pre class="brush: c++;" style="overflow: hidden;">
/*
	Assignment: Ray Tracer
	Authors: Hardik Bhatt

	Desctiption:
	for each pixel of the screen
	{
	  Final color = 0;
	  Ray = { starting point, direction };
	  Repeat 
	  {
		for each object in the scene
		{
		  determine closest ray object/intersection;
		}  
		if intersection exists 
		{
		  for each light in the scene
		  {
			if the light is not in shadow of another object
			{
			  add this light contribution to computed color;
			}      
		  }
		}
		Final color = Final color + computed color * previous reflection factor;
		reflection factor = reflection factor * surface reflection property;
		increment depth;
	  } until reflection factor is 0 or maximum depth is reached;
	}  
*/

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib> // for exit function
#include <sstream>
#include <math.h>

using namespace std;

#include "raytrace.h"

//Writing a PPM output file that takes in the calculated 
//color and outputs it onto the file
void writePPM(struct RGBColor3f **color)
{
	int i, j;
	FILE *fp = fopen(outfileName, "wb"); /* b - binary mode */
	(void) fprintf(fp, "P6\n%d %d\n255\n", width, height);

	/*------------------Log Code------------------//
	printf("Loging writePPM\n");
	FILE *logPPM = fopen("logPPM.txt", "at");
    if (!logPPM) logPPM = fopen("logPPM.txt", "wt");
	/*------------------Log Code------------------*/
	for (i = 0; i < height; ++i)
	{
		for (j = 0; j < width; ++j)
		{
			
			static unsigned char writeColor[3];
			writeColor[0] = (int)(color[i][j].R * 255);  /* red */
			writeColor[1] = (int)(color[i][j].G * 255);  /* green */
			writeColor[2] = (int)(color[i][j].B * 255);  /* blue */
			/*------------------Log Code------------------//
			if (!logPPM) {
				printf("can not open logfile.txt for writing.\n");
				exit(1);   // bail out if we can't log
			}
			// Insert whatever you want logged here
			fprintf(logPPM,"%1d %1d %d %d %d\n", i, j, writeColor[0], writeColor[1], writeColor[2]);
			/*------------------Log Code------------------*/
			(void) fwrite(writeColor, 1, 3, fp);
		}
	}
	/*------------------Log Code------------------//
	(void) fclose(logPPM);
	/*------------------Log Code------------------*/
	(void) fclose(fp);
}

//Cross Product function
struct Vector3f CrossProduct3(struct Vector3f a, struct Vector3f b)
{
	struct Vector3f result;

	result.x = (a.y * b.z) - (a.z*b.y);
	result.y = -((b.z * a.x) - (b.x * a.z));
	result.z = (a.x * b.y) - (a.y * b.x);
	//printf("result: %1f %1f %1f\n\n",result.x, result.y, result.z);
    return result;
}

//Dot Product function
float Dot3(struct Vector3f a, struct Vector3f b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

//scale vector by the scale factor
struct Vector3f Scale3(struct Vector3f a, float scale)
{
	struct Vector3f result;

	result.x = a.x * scale;
	result.y = a.y * scale;
	result.z = a.z * scale;
	
	return result;
}

//normalize given vector
struct Vector3f Normalize3(struct Vector3f a)
{
  float length;

  length = (float) sqrt(Dot3(a, a));
  return Scale3(a, 1 / length);
}

//add up the two vector and return the result
struct Vector3f addv(struct Vector3f a, struct Vector3f b){
	struct Vector3f result={0, 0, 0};
	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;
	return result;
}

//add the two given colors together and return the result
struct RGBColor3f addc( struct RGBColor3f a, struct RGBColor3f b){
	struct RGBColor3f result={0,0,0};
	result.R = a.R + b.R;
	result.G = a.G + b.G;
	result.B = a.B + b.G;
	return result;
}
  /*
transmit: Snell's law:  n1*sin(tempior) = n2*sin(theta2).
*/
struct ray transmit(struct ray R,struct Vector3f P,struct Vector3f n, float ior) 
{
       struct ray returnValue;
       returnValue.org.x = P.x;
       returnValue.org.y = P.y;
       returnValue.org.z = P.z;
       struct Vector3f v = {-R.dir.x,-R.dir.y,-R.dir.z};//direction of incoming ray
       v = Normalize3(v);
       struct Vector3f u1 = {0,0,0};
       u1.x = n.x*(Dot3(v, n));
       u1.y = n.y*(Dot3(v, n));
       u1.z = n.z*(Dot3(v, n));
       struct Vector3f w1 = {0,0,0};
       w1.x = u1.x - v.x;
       w1.y = u1.y - v.y;
       w1.z = u1.z - v.z;//abs
       struct Vector3f w2 = {0,0,0};
       w2.x = (1/ior)*(u1.x - v.x);
       w2.y = (1/ior)*(u1.y - v.y);
       w2.z = (1/ior)*(u1.z - v.z);
       float cosO1 = Dot3(v,n);
       float cosO2 = sqrt(1-((1/ior)*(1/ior))*(1-(cosO1*cosO1)));
       returnValue.dir.x = (((1/ior) * cosO1) -cosO2)*n.x - (1/ior)*v.x;
       returnValue.dir.y = (((1/ior) * cosO1) -cosO2)*n.y - (1/ior)*v.y;
       returnValue.dir.z = (((1/ior) * cosO1) -cosO2)*n.z - (1/ior)*v.z;
       
       return returnValue;
}

struct ray reflect(struct ray R,struct Vector3f P,struct Vector3f n) 
{
	struct ray returnValue;
	returnValue.org.x = P.x;
	returnValue.org.y = P.y;
	returnValue.org.z = P.z;
	struct Vector3f v = {-R.dir.x,-R.dir.y,-R.dir.z};
	v = Normalize3(v);
	returnValue.dir.x = 2*(Dot3(n,v))*n.x-v.x;  //2(n.v)n-v
	returnValue.dir.y = 2*(Dot3(n,v))*n.y-v.y;
	returnValue.dir.z = 2*(Dot3(n,v))*n.z-v.z;
	return returnValue;
}
 
//-----------------------------------------------------------------------
// Normalise program
// 
//-----------------------------------------------------------------------
void calcTriNormal (long j, long index1, long index2, long index3)
{
    struct Vector3f v1;
    struct Vector3f v2;
 
    struct Vector3f v3;
 
    // Finds The Vector Between 2 Points By Subtracting
    // The x,y,z Coordinates From One Point To Another.
    v1.x = TriangleVArray[index1].ver.x;
    v1.y = TriangleVArray[index1].ver.y;
    v1.z = TriangleVArray[index1].ver.z;
     
    v2.x = TriangleVArray[index2].ver.x;
    v2.y = TriangleVArray[index2].ver.y;
    v2.z = TriangleVArray[index2].ver.z;
 
    v3.x = TriangleVArray[index3].ver.x;
    v3.y = TriangleVArray[index3].ver.y;
    v3.z = TriangleVArray[index3].ver.z;
 
    // Calculate The Vector From Point 1 To Point 0
    p1.x = v1.x - v2.x;                 // Vector 1.x=Vertex[0].x-Vertex[1].x
    p1.y = v1.y - v2.y;                 // Vector 1.y=Vertex[0].y-Vertex[1].y
    p1.z = v1.z - v2.z;                 // Vector 1.z=Vertex[0].y-Vertex[1].z
    // Calculate The Vector From Point 2 To Point 1
    p2.x = v2.x - v3.x;                 // Vector 2.x=Vertex[0].x-Vertex[1].x
    p2.y = v2.y - v3.y;                 // Vector 2.y=Vertex[0].y-Vertex[1].y
    p2.z = v2.z - v3.z;                 // Vector 2.z=Vertex[0].z-Vertex[1].z
    // Compute The Cross Product To Give Us A Surface Normal
    TriangleFArray[j].normal_tri.x = (p1.y*p2.z) - (p1.z*p2.y);              // Cross Product For Y - Z
    TriangleFArray[j].normal_tri.y = (p1.z*p2.x) - (p1.x*p2.z);              // Cross Product For X - Z
    TriangleFArray[j].normal_tri.z = (p1.x*p2.y) - (p1.y*p2.x);              // Cross Product For X - Y
}
 
void calcVerNormal(long j, long index1, long index2, long index3)
{
    //compute vertex normals  by adding traignle normals to vertex normals
    TriangleVArray[index1].normal_ver.x = TriangleVArray[index1].normal_ver.x + TriangleFArray[j].normal_tri.x;
    TriangleVArray[index2].normal_ver.y = TriangleVArray[index2].normal_ver.y + TriangleFArray[j].normal_tri.y;
    TriangleVArray[index3].normal_ver.z = TriangleVArray[index3].normal_ver.z + TriangleFArray[j].normal_tri.z;
}

//read the file given the file name and store it in the appropriate veriables
void readfile(char *filename)
{
	FILE *fp;

	if((fp=fopen(filename, "r")) == NULL) {
		printf("Cannot open file.\n");
		exit(1);
	}

	fscanf(fp, "%s", outfileName);
	fscanf(fp, "%d %d", &width, &height);
	fscanf(fp, "%f %f %f\n", &camera.x, &camera.y, &camera.z);
	fscanf(fp, "%f %f %f\n", &at.x, &at.y, &at.z);
	fscanf(fp, "%f %f %f\n", &up.x, &up.y, &up.z);
	fscanf(fp, "%d\n", &fovy);
	fscanf(fp, "%d\n", &numL);
	for(int i = 0; i < numL; i++)
	{
		fscanf(fp, "%f %f %f %f %f %f %f %f %f\n", &LightArray[i].ver.x, &LightArray[i].ver.y, &LightArray[i].ver.z, 
			&LightArray[i].clr.R, &LightArray[i].clr.G, &LightArray[i].clr.B, 
			&LightArray[i].attenuationA, &LightArray[i].attenuationB, &LightArray[i].attenuationC);
	}
	fscanf(fp, "%d\n", &numP);
	for(int i = 0; i < numP; i++)
	{
		fscanf(fp, "%s", PigmentArray[i].name);
		if(strcmp(PigmentArray[i].name,"solid")==0)
		{
			fscanf(fp, "%f %f %f\n", &PigmentArray[i].c1.R, &PigmentArray[i].c1.G, &PigmentArray[i].c1.B);
			PigmentArray[i].c2.R = 0;
			PigmentArray[i].c2.G = 0;
			PigmentArray[i].c2.B = 0;
			PigmentArray[i].s = 0;
		}
		else if(strcmp(PigmentArray[i].name,"checker")==0)
		{
			fgetc(fp);
			fscanf(fp, "%f %f %f %f %f %f %f\n", &PigmentArray[i].c1.R, &PigmentArray[i].c1.G, &PigmentArray[i].c1.B, 
				&PigmentArray[i].c2.R, &PigmentArray[i].c2.G, &PigmentArray[i].c2.B, &PigmentArray[i].s);
		}
	}
	fscanf(fp, "%d\n", &numF);
	for(int i = 0; i < numF; i++)
	{
		fscanf(fp, "%f %f %f %f %f %f %f\n", &SurfaceFinishesArray[i].ka, &SurfaceFinishesArray[i].kd, &SurfaceFinishesArray[i].ks, 
			&SurfaceFinishesArray[i].shine, &SurfaceFinishesArray[i].kr, &SurfaceFinishesArray[i].kt, &SurfaceFinishesArray[i].ior);
	}
	fscanf(fp, "%d\n", &numT);
	for(int i = 0; i < numT; i++)
	{
		fscanf(fp, "%s %f %f %f", TransformationArray[i].name, &TransformationArray[i].vec.x, &TransformationArray[i].vec.y, &TransformationArray[i].vec.z);
	}
	fscanf(fp, "%d\n", &numO);
	for(int i = 0; i < numO; i++)
	{
		int numP_temp;
		int numS_temp;
		int numT_temp;
		char temp_name[100];

		fscanf(fp, "%d %d %d", &numP_temp, &numS_temp, &numT_temp);

		ObjectArray[i].numP = numP_temp;
		ObjectArray[i].numS = numS_temp;
		ObjectArray[i].numT = numT_temp;
		for(int j=0; j < ObjectArray[i].numT; j++)
		{
			fscanf(fp, "%d", &numTransform[j]);
		}
		fscanf(fp, "%s", temp_name);
		strcpy (ObjectArray[i].name, temp_name);


		if(strcmp( ObjectArray[i].name,"sphere")==0)
		{
			ObjectArray[i].numPoly = 0;
			fscanf(fp, "%f %f %f %f\n", &SphereArray[i].x, &SphereArray[i].y, &SphereArray[i].z, &SphereArray[i].r);
			if(ObjectArray[i].numT >= 1 )
			{
				for(int i = 0; i < ObjectArray[i].numT; i++)
				{
					if(strcmp( TransformationArray[i].name, "scale")==0)
					{
						SphereArray[i].x = SphereArray[i].r * TransformationArray[i].vec.x;
					}
					else if(strcmp( TransformationArray[i].name, "translate")==0)
					{
						SphereArray[i].x = SphereArray[i].x + TransformationArray[i].vec.x;
						SphereArray[i].y = SphereArray[i].y + TransformationArray[i].vec.y;
						SphereArray[i].z = SphereArray[i].z + TransformationArray[i].vec.z;
					}
				}
			}
		}
		else if(strcmp(ObjectArray[i].name,"polyhedron")==0)
		{
			fscanf(fp, "%d", &ObjectArray[i].numPoly);
			for(int j=0; j < ObjectArray[i].numPoly; j++)
			{
				fscanf(fp, "%f %f %f %f\n",  &PolyhedronArray[polyIndex].coefA, &PolyhedronArray[polyIndex].coefB,  &PolyhedronArray[polyIndex].coefC,  &PolyhedronArray[polyIndex].coefD);
				polyIndex++;
			}
		}
		else if(strcmp(ObjectArray[i].name,"trianglemesh")==0)
		{
			FILE *plyFile;
			long k, l;

			fscanf(fp, "%s", TrianglemeshArray[i].file);
			if ((plyFile = fopen(TrianglemeshArray[i].file, "r")) == NULL)
				  exit(0);
			 
			if(fscanf(plyFile, "%d\n", &TrianglemeshArray[i].N) == EOF)
			{
				printf("P: There is not data in input file\n");
				exit(0);
			}
			printf("The Number of vectors %d\n", TrianglemeshArray[i].N);

			if(fscanf(plyFile, "%d\n", &TrianglemeshArray[i].M) == EOF)
			{
			printf("P: There is not data in input file\n");
			exit(0);
			}
			printf("The Number of triangles %d \n", TrianglemeshArray[i].M);

			TriangleVArray = (struct triangleVector *)malloc(TrianglemeshArray[i].N * sizeof(struct triangleVector));
			for (k = 0; k < TrianglemeshArray[i].N; k++)
			{
				if(fscanf(plyFile, "%s %f %f %f\n", TriangleVArray[k].v, &TriangleVArray[k].ver.x, &TriangleVArray[k].ver.y, &TriangleVArray[k].ver.z) != EOF)
				{
					if(ObjectArray[i].numT >= 1 )
					{
						for(int i = 0; i < ObjectArray[i].numT; i++)
						{
							if(strcmp( TransformationArray[i].name, "scale")==0)
							{
								TriangleVArray[k].ver.x = TriangleVArray[k].ver.x * TransformationArray[i].vec.x;
								TriangleVArray[k].ver.y = TriangleVArray[k].ver.y * TransformationArray[i].vec.y;
								TriangleVArray[k].ver.z = TriangleVArray[k].ver.z * TransformationArray[i].vec.z;
	
							}
							else if(strcmp( TransformationArray[i].name, "translate")==0)
							{
								
								TriangleVArray[k].ver.x = TriangleVArray[k].ver.x + TransformationArray[i].vec.x;
								TriangleVArray[k].ver.y = TriangleVArray[k].ver.y + TransformationArray[i].vec.y;
								TriangleVArray[k].ver.z = TriangleVArray[k].ver.z + TransformationArray[i].vec.z;
								
							}
						}
					}
					TriangleVArray[k].normal_ver.x = 0;
					TriangleVArray[k].normal_ver.y = 0;
					TriangleVArray[k].normal_ver.z = 0;
					ave_vector.x += TriangleVArray[k].ver.x;
					ave_vector.y += TriangleVArray[k].ver.y;
					ave_vector.z += TriangleVArray[k].ver.z;
					//printf("The vector array %c %f %f %f\n", &TriangleVArray[k].v, &TriangleVArray[k].ver.x, &TriangleVArray[k].ver.y, &TriangleVArray[k].ver.z);
				}
				else
				{
					printf("P: There is not data in input file\n");
					exit(0);
				}
			}

			ave_vector.x = ave_vector.x / TrianglemeshArray[i].N;
			ave_vector.y = ave_vector.y / TrianglemeshArray[i].N;
			ave_vector.z = ave_vector.z / TrianglemeshArray[i].N;
			/*at[0] = (double) ave_vector.x;
			at[1] = (double) ave_vector.y;
			at[2] = (double) ave_vector.z;*/

			TriangleFArray = (struct triangleFaces *)malloc(TrianglemeshArray[i].M * sizeof(struct triangleFaces));

			for (l = 0; l < TrianglemeshArray[i].M; l++)
			{
				 
				if(fscanf(plyFile, "%s %ld %ld %ld\n", TriangleFArray[l].f, &TriangleFArray[l].vertex0, &TriangleFArray[l].vertex1, &TriangleFArray[l].vertex2) != EOF)
				{
					//printf("The triangle array %ld %ld %ld\n", TriangleArray[l].vertex0, TriangleArray[l].vertex1, TriangleArray[l].vertex2);
					//printf("i am in front of triangle norlal\n");
					calcTriNormal(l, TriangleFArray[l].vertex0, TriangleFArray[l].vertex1, TriangleFArray[l].vertex2);
					calcVerNormal(l, TriangleFArray[l].vertex0, TriangleFArray[l].vertex1, TriangleFArray[l].vertex2);
				}
				else
				{
					printf("P: There is not data in input file\n");
					exit(0);
				}
			}  
		}
	}

	fclose(fp);
}

//calculate the noemals given the 3 vector points
struct Vector3f CalculateSurfaceNormal(struct Vector3f Vector1, struct Vector3f Vector2, struct Vector3f Vector3, bool NORMALIZE){
   
	struct Vector3f Normal,v1,v2, returnVector;

	float NormalisationFactor, CombinedSquares;
	v1.x = Vector2.x - Vector1.x;
	v1.y = Vector2.y - Vector1.y;
	v1.z = Vector2.z - Vector1.z;
	v2.x = Vector3.x - Vector1.x;
	v2.y = Vector3.y - Vector1.y;
	v2.z = Vector3.z - Vector1.z;
	Normal.x = (v1.y * v2.z) - (v1.z * v2.y);
	Normal.y = -((v2.z * v1.x) - (v2.x * v1.z));
	Normal.z = (v1.x * v2.y) - (v1.y * v2.x);
	if(NORMALIZE){
		CombinedSquares = (Normal.x * Normal.x) + 
		(Normal.y * Normal.y) + 
		(Normal.z * Normal.z);
		NormalisationFactor = sqrt(CombinedSquares);
		returnVector.x = Normal.x / NormalisationFactor;
		returnVector.y = Normal.y / NormalisationFactor;
		returnVector.z = Normal.z / NormalisationFactor;
	} else {
		returnVector.x = Normal.x;
		returnVector.y = Normal.y;
		returnVector.z = Normal.z;
	}
	return returnVector;
}

bool sameside(struct Vector3f p, struct Vector3f a1, struct Vector3f a2, struct Vector3f a3)
{
	struct Vector3f cp1,cp2;
	struct Vector3f tempcp1, tempcp2, temp1, temp2;
	tempcp1.x = a2.x - a1.x;
	tempcp1.y = a2.y - a1.y;
	tempcp1.z = a2.z - a1.z;
	temp1.x = p.x - a1.x;
	temp1.y = p.y - a1.y;
	temp1.z = p.z - a1.z;
	cp1 = CrossProduct3(tempcp1, temp1);

	tempcp2.x = a2.x - a1.x;
	tempcp2.y = a2.y - a1.y;
	tempcp2.z = a2.z - a1.z;
	temp2.x = a3.x - a1.x;
	temp2.y = a3.y - a1.y;
	temp2.z = a3.z - a1.z;
	cp2=CrossProduct3(tempcp2, temp2);

	if(Dot3(cp1, cp2) >= 0)
		return true;
	else 
		return false;
}

bool PointInTriangle(struct Vector3f p, struct Vector3f a, struct Vector3f b, struct Vector3f c)
{
	if(sameside(p,a,b,c) && sameside(p,b,c,a) && sameside(p,c,a,b))
		return true;
	else return false;
}


//intersect function which determins if a given ray intersect with an object in the scene and return the point and update status
struct Vector3f intersect(struct ray tempRay, int *status)
{
	tempRay.dir = Normalize3(tempRay.dir);
	struct Vector3f p ={0,0,0};
	struct Vector3f u,u1;
	float t = 10000.0;                        /////////
	float t1 = (float) 0.0;
	float t2 = (float) 0.0;
    float EPS = (float) 0.1;
	/*------------------Log Code------------------//
	//printf("Loging intersect\n");
	FILE *logIS = fopen("logIntersect.txt", "at");
	if (!logIS) logIS = fopen("logIntersect.txt", "wt");
	/*------------------Log Code------------------*/
	polyIndex = 0;
	for(int k = 0; k < numO; k++)
	{
		if(strcmp( ObjectArray[k].name,"sphere")==0)
		{	
			//if the object is sphere
			u.x = ((float)SphereArray[k].x) - tempRay.org.x;
			u.y	= ((float)SphereArray[k].y) - tempRay.org.y; 
			u.z = ((float)SphereArray[k].z) - tempRay.org.z;
		
			u1.x = u.x - Dot3(tempRay.dir,u)*tempRay.dir.x;
			u1.y = u.y - Dot3(tempRay.dir,u)*tempRay.dir.y;
			u1.z = u.z - Dot3(tempRay.dir,u)*tempRay.dir.z;
			float delta= (((float)(SphereArray[k].r*SphereArray[k].r)) - Dot3(u1,u1));
			 
			
			/*------------------Log Code------------------//
			if (!logIS) {
				printf("can not open logIntersect.txt for writing.\n");
				exit(1);   // bail out if we can't log
			}
			
			// Insert whatever you want logged here
			fprintf(logIS,"%1d %1d %1d %f %f %f %f\n", k, i, j, u1.x, u1.y, u1.z, delta);
			/*------------------Log Code------------------*/

			if(delta > EPS) {
				t1 = Dot3(tempRay.dir,u) - sqrt(delta);
				t2 = Dot3(tempRay.dir,u) + sqrt(delta);
				
				if(t1 > EPS && t2 >EPS && t1 - t<EPS )
				{
					   t=t1;
					   *status=k;
					   p.x = tempRay.org.x + t*tempRay.dir.x;
					   p.y = tempRay.org.y + t*tempRay.dir.y;
					   p.z = tempRay.org.z + t*tempRay.dir.z;
					   global_normal.x = (float)( p.x - SphereArray[k].x); 
					   global_normal.y = (float)( p.y - SphereArray[k].y); 
					   global_normal.z = (float)( p.z - SphereArray[k].z); 
				}
				else if(t1 < EPS && t2 > EPS && t2 - t<EPS)
				{
					   t=t2;
					   *status=k;
					   p.x = tempRay.org.x + t*tempRay.dir.x;
					   p.y = tempRay.org.y + t*tempRay.dir.y;
					   p.z = tempRay.org.z + t*tempRay.dir.z;
					   global_normal.x = (float)(SphereArray[k].x - p.x );
					   global_normal.y = (float)(SphereArray[k].y - p.y ); 
					   global_normal.z = (float)(SphereArray[k].z - p.z ); 
				       
				}
			}
		}
		/////////////////
		else if(strcmp(ObjectArray[k].name,"polyhedron")==0)
		{
			int in=1;
			int out=-1;
			float tin = -1;
			float tout = 10000;
			for(int j=0; j < ObjectArray[k].numPoly; j++)
			{
				float denom =  PolyhedronArray[polyIndex].coefA*tempRay.dir.x + PolyhedronArray[polyIndex].coefB*tempRay.dir.y+ PolyhedronArray[polyIndex].coefC*tempRay.dir.z;
				float numer = - PolyhedronArray[polyIndex].coefA*tempRay.org.x - PolyhedronArray[polyIndex].coefB*tempRay.org.y- PolyhedronArray[polyIndex].coefC*tempRay.org.z- PolyhedronArray[polyIndex].coefD;
				if(numer<EPS){ // start point outside the face
					if((denom<EPS)&&(numer/denom>=tin)) {
						tin=numer/denom;
						in=j;
					}
				}
				if(numer>=EPS){ // start point inside the face
					if((denom>EPS)&&(numer/denom<=tout)) {
						tout=numer/denom;
						out=j;
					}
				}			
				polyIndex++;
			}
			if(tin - tout<EPS){
				if(tin >= EPS && (tin - t<EPS))
				{
					t=tin;
					*status = k;
					p.x = tempRay.org.x + t*tempRay.dir.x;
					p.y = tempRay.org.y + t*tempRay.dir.y;
					p.z = tempRay.org.z + t*tempRay.dir.z;
					global_normal.x = PolyhedronArray[in].coefA;
					global_normal.y = PolyhedronArray[in].coefB;
					global_normal.z = PolyhedronArray[in].coefC;
				}
				if(tout>=EPS&&tout - t<EPS)
				{
					t=tout;
					*status=k;
					p.x = tempRay.org.x + t*tempRay.dir.x;
					p.y = tempRay.org.y + t*tempRay.dir.y;
					p.z = tempRay.org.z + t*tempRay.dir.z;
					global_normal.x = -PolyhedronArray[out].coefA;
					global_normal.y = -PolyhedronArray[out].coefB;
					global_normal.z = -PolyhedronArray[out].coefC;
				}
			}
		}
		/////////////////
		if(strcmp( ObjectArray[k].name,"trianglemesh")==0)
		{
			for(int i=0; i< TrianglemeshArray[k].M; i ++)
			{
				struct Vector3f tempa = TriangleVArray[TriangleFArray[i].vertex0].ver;
				struct Vector3f tempb = TriangleVArray[TriangleFArray[i].vertex1].ver;
				struct Vector3f tempc = TriangleVArray[TriangleFArray[i].vertex2].ver;
				struct Vector3f tempnormal = {0,0,0};
				tempb.x = tempb.x - tempa.x;
				tempb.y = tempb.y - tempa.y;
				tempb.z = tempb.z - tempa.z;
				tempc.x = tempc.x - tempa.x;
				tempc.y = tempc.y - tempa.y;
				tempc.z = tempc.z - tempa.z;
				tempnormal = CrossProduct3(tempb, tempc);
				tempa.x = tempRay.org.x - tempa.x;
				tempa.y = tempRay.org.y - tempa.y;
				tempa.z = tempRay.org.z - tempa.z;
				int tempt = Dot3(tempa, tempnormal)/Dot3(tempRay.dir, tempnormal);
				struct Vector3f temp = {0,0,0};
				temp.x = tempRay.org.x + tempt*tempRay.dir.x;
				temp.y = tempRay.org.y + tempt*tempRay.dir.y;
				temp.z = tempRay.org.z + tempt*tempRay.dir.z;
				if(tempt < t && PointInTriangle(temp, tempa, tempb, tempc))
				{
					p = temp;
					*status = k;
					global_normal = tempnormal;
				}
			}
		}
	}
	/*------------------Log Code------------------//
	fclose(logIS);
	/*------------------Log Code------------------*/
	
	return p;
}

float visIntersect(struct ray tempRay)
{
	struct Vector3f p ={0,0,0};
	tempRay.dir = Normalize3(tempRay.dir);
	struct Vector3f u,u1;
	float t = 10000.0;                        /////////
	float t1 = (float) 0.0;
	float t2 = (float) 0.0;
	polyIndex = 0;
	for(int k = 0; k < numO; k++)
	{
		if(strcmp( ObjectArray[k].name,"sphere")==0)
		{	
			//if the object is sphere
			u.x = ((float)SphereArray[k].x) - tempRay.org.x;
			u.y	= ((float)SphereArray[k].y) - tempRay.org.y; 
			u.z = ((float)SphereArray[k].z) - tempRay.org.z;
		
			u1.x = u.x - Dot3(tempRay.dir,u)*tempRay.dir.x;
			u1.y = u.y - Dot3(tempRay.dir,u)*tempRay.dir.y;
			u1.z = u.z - Dot3(tempRay.dir,u)*tempRay.dir.z;
			float delta= (((float)(SphereArray[k].r*SphereArray[k].r)) - Dot3(u1,u1));

			if(delta >= EPS) {
				t1 = Dot3(tempRay.dir,u) - sqrt(delta);
				t2 = Dot3(tempRay.dir,u) + sqrt(delta);
				if(t1 > EPS && t1 - t<EPS)
				{
					t=t1;
				}
				else if(t2 - t<EPS && t2 > EPS)
				{
					t=t2;
				}
			}
		}
		else if(strcmp(ObjectArray[k].name,"polyhedron")==0)
		{
			int in=1;
			int out=-1;
			float tin = -1;
			float tout = 10000;
			for(int j=0; j < ObjectArray[k].numPoly; j++)
			{
				float denom =  PolyhedronArray[polyIndex].coefA*tempRay.dir.x + PolyhedronArray[polyIndex].coefB*tempRay.dir.y+ PolyhedronArray[polyIndex].coefC*tempRay.dir.z;
				float numer = - PolyhedronArray[polyIndex].coefA*tempRay.org.x - PolyhedronArray[polyIndex].coefB*tempRay.org.y- PolyhedronArray[polyIndex].coefC*tempRay.org.z- PolyhedronArray[polyIndex].coefD;
				
				if(numer<EPS){ // start point outside the face
					if((denom<EPS)&&(numer/denom>=tin)) {
						tin=numer/denom;
						in=j;
					}
				}
				if(numer>=EPS){ // start point inside the face
					if((denom>0)&&(numer/denom<=tout)) {
						tout=numer/denom;
						out=j;
					}
				}			
				polyIndex++;
			}
			if(tin - tout<EPS){
				if(tin >= EPS && (tin < t))
				{
					t = tin;
				}
				if(tout >= EPS && tout < t)
				{
					t=tout;
				}
			}
		}
		
		if(strcmp( ObjectArray[k].name,"trianglemesh")==0)
		{
			for(int i=0; i< TrianglemeshArray[k].M; i ++)
			{
				struct Vector3f tempa = TriangleVArray[TriangleFArray[i].vertex0].ver;
				struct Vector3f tempb = TriangleVArray[TriangleFArray[i].vertex1].ver;
				struct Vector3f tempc = TriangleVArray[TriangleFArray[i].vertex2].ver;
				struct Vector3f tempnormal = {0,0,0};
				tempb.x = tempb.x - tempa.x;
				tempb.y = tempb.y - tempa.y;
				tempb.z = tempb.z - tempa.z;
				tempc.x = tempc.x - tempa.x;
				tempc.y = tempc.y - tempa.y;
				tempc.z = tempc.z - tempa.z;
				tempnormal = CrossProduct3(tempb, tempc);
				tempa.x = tempRay.org.x - tempa.x;
				tempa.y = tempRay.org.y - tempa.y;
				tempa.z = tempRay.org.z - tempa.z;
				int tempt = Dot3(tempa, tempnormal)/Dot3(tempRay.dir, tempnormal);
				struct Vector3f temp = {0,0,0};
				temp.x = tempRay.org.x + t*tempRay.dir.x;
				temp.y = tempRay.org.y + t*tempRay.dir.y;
				temp.z = tempRay.org.z + t*tempRay.dir.z;
				if(tempt > EPS && tempt < t && tempt > 0 && PointInTriangle(temp, tempa, tempb, tempc))
				{
					t = tempt;				
				}
			}
		}
	}
	return t;
}

//check if the object within the scene is visible
bool visible( struct Vector3f p, int k, int *status)
{
	bool vis = true;
	struct ray tempRay = {{0,0,0},{0,0,0}};
	tempRay.org = p;
	tempRay.dir.x = LightArray[k].ver.x-p.x;
	tempRay.dir.y = LightArray[k].ver.y-p.y;
	tempRay.dir.z = LightArray[k].ver.z-p.z;
	float d = Dot3( tempRay.dir, tempRay.dir);
	d = sqrt(d);
	float t = visIntersect(tempRay);
	if(t <= d) return false;
	else return true;	
}

//return which is larger
float max(float right, float left)
{
	if(right > left)
		return right;
	else 
		return left;
}

//trace the ray and determine the local color of the pixel within the scene
struct RGBColor3f trace(struct ray tempRay, int depth)        /////////
{
	struct RGBColor3f locClr = {0,0,0};
	struct RGBColor3f transmitC = {0,0,0};
	struct RGBColor3f reflectC = {0,0,0};
	struct RGBColor3f tempcolor = {0,0,0};
	struct Vector3f objP = {0,0,0};
	struct Vector3f normal = {0,0,0};
	int status = -1;
    float tempka = 0;
	float tempkd = 0;
	float tempks= 0;
	float tempshine= 0;
	float tempkr= 0;
	float tempkt= 0;
	float tempior= 0;
	
	tempRay.dir = Normalize3(tempRay.dir);

	if(depth > DEPTH)
	{
		return BGColor;
	}
	objP = intersect(tempRay, &status);
	normal.x = global_normal.x;
	normal.y = global_normal.y;
	normal.z = global_normal.z;
	normal = Normalize3(normal);

	if(status == -1)
		return BGColor;
	else
	{
		if(strcmp( PigmentArray[ObjectArray[status].numP].name,"solid")==0)
		{
            tempcolor.R = PigmentArray[ObjectArray[status].numP].c1.R;
			tempcolor.G = PigmentArray[ObjectArray[status].numP].c1.G;
			tempcolor.B = PigmentArray[ObjectArray[status].numP].c1.B;
		} 
		else if (strcmp( PigmentArray[ObjectArray[status].numP].name,"checker")==0)
		{
            float x1,y1,z1;
            int x2,y2,z2;
            x1 = (float)objP.x/PigmentArray[ObjectArray[status].numP].s;
            y1 = (float)objP.y/PigmentArray[ObjectArray[status].numP].s;
            z1 = (float)objP.z/PigmentArray[ObjectArray[status].numP].s;
			if(abs(z1)<EPS)
				z1=0.0;
			if(abs(x1)<EPS)
				x1=0.0;
			if(abs(y1)<EPS)
				y1=0.0;
            x2 = floor(x1);y2= floor(y1);z2= floor(z1);
			if ((x2+y2+z2)%2 != 0)
			{
				tempcolor.R = PigmentArray[ObjectArray[status].numP].c1.R;
				tempcolor.G = PigmentArray[ObjectArray[status].numP].c1.G;
				tempcolor.B = PigmentArray[ObjectArray[status].numP].c1.B;
			} else {
				tempcolor.R = PigmentArray[ObjectArray[status].numP].c2.R;
				tempcolor.G = PigmentArray[ObjectArray[status].numP].c2.G;
				tempcolor.B = PigmentArray[ObjectArray[status].numP].c2.B;
            }
        }
		tempka = SurfaceFinishesArray[ObjectArray[status].numS].ka;
		tempkd = SurfaceFinishesArray[ObjectArray[status].numS].kd;
		tempks = SurfaceFinishesArray[ObjectArray[status].numS].ks;
		tempshine = SurfaceFinishesArray[ObjectArray[status].numS].shine;
		tempkr = SurfaceFinishesArray[ObjectArray[status].numS].kr;
		tempkt = SurfaceFinishesArray[ObjectArray[status].numS].kt;
		tempior = SurfaceFinishesArray[ObjectArray[status].numS].ior;
	}

	//normal = compute_normal(objP);
	locClr.R = tempka * tempcolor.R * LightArray[0].clr.R;
	locClr.G = tempka * tempcolor.G * LightArray[0].clr.G;
	locClr.B = tempka * tempcolor.B * LightArray[0].clr.B;
	
	for(int j = 1; j < numL; j++)
	{   
		if(visible(objP,j,&status))
		{
			struct Vector3f l = { LightArray[j].ver.x-objP.x, LightArray[j].ver.y - objP.y,  LightArray[j].ver.z - objP.z};
			
			float d = (float)sqrt(Dot3(l, l));
			d =  LightArray[j].attenuationA + d * LightArray[j].attenuationB + d * d * LightArray[j].attenuationC;

			l = Normalize3(l);
			struct Vector3f v = { camera.x-objP.x, camera.y - objP.y,  camera.z - objP.z};
			v = Normalize3(v);
			struct Vector3f h = Normalize3 ( addv( l, v));
			h = Normalize3(h);

			locClr.R = locClr.R + LightArray[j].clr.R * (tempcolor.R * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;
            locClr.G = locClr.G + LightArray[j].clr.G * (tempcolor.G * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;
			locClr.B = locClr.B + LightArray[j].clr.B * (tempcolor.B * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;		
			}
	}

	if(tempkr>0){
		struct ray Rr = reflect( tempRay, objP, normal);
		reflectC = trace (Rr, depth+1);
		reflectC.R *=  tempkr;
		reflectC.G *=  tempkr;
		reflectC.B *=  tempkr;
	}
	if(tempkt>0){
		struct ray Rt=transmit ( tempRay, objP, normal,tempior);
        transmitC = trace (Rt, depth+1);
		transmitC.R *= tempkt;
		transmitC.G *= tempkt;
		transmitC.B *= tempkt;
	}
	
	return addc(locClr, addc(reflectC,transmitC));
}

//computer the projection of the ray
struct ray compute(float i, float j)        ///////////////
{
	float w, h, px, py;
	struct Vector3f p;
	struct ray tempRay1;
	float param, result;

	param = (float) fovy;
	result = tan (param*PI/360);
	//printf ("The tangent of %lf degrees is %lf.\n", param, result );



	w = 2.0 * result;
	h = w * ((float)(height/width));

	px = (w * ((float)j / (float)width)) - (w/2);
	py = (-h * ((float)i / (float)height)) + (h/2);
	
	float temp = (float)px * (float)CX.x;
	p.x = camera.x + (px * CX.x) + (py * CY.x) - CZ.x;
	p.y = camera.y + (px * CX.y) + (py * CY.y) - CZ.y;
	p.z = camera.z + (px * CX.z) + (py * CY.z) - CZ.z;
    
	tempRay1.org = camera;
	tempRay1.dir.x = (p.x - camera.x);
	tempRay1.dir.y = (p.y - camera.y); 
	tempRay1.dir.z = (p.z - camera.z);

	tempRay1.dir = Normalize3(tempRay1.dir);
	//printf ("The tangent of %lf degrees is %lf.\n", param, result );
	//printf("w h: %i %i %1f %1f\n",height, width, w, h);
	//printf("i j px py: %i %i %1f %1f\n", i, j, px, px);
	//printf("temp: %1f\n", temp);
	//printf("p.: %1f %1f %1f\n", p.x, p.y, p.z);
	//printf("tempRay1.: %1f %1f %1f\n", tempRay1.dir.x, tempRay1.dir.y, tempRay1.dir.z);

	return tempRay1;
}

//calculate the camara coordinate for the ray
void cameraCoordinates()
{
	CZ.x = -(at.x-camera.x);
	CZ.y = -(at.y-camera.y);
	CZ.z = -(at.z-camera.z);
	CZ = Normalize3(CZ);
	//printf("CZ: %f %f %f\n\n",CZ.x, CZ.y, CZ.z);
	CX = Normalize3(CrossProduct3(up, CZ));
	//printf("CX: %f %f %f\n",CX.x, CX.y, CX.z);
	CY = CrossProduct3(CZ, CX);
	//printf("CY: %f %f %f\n",CY.x, CY.y, CY.z);
}

//render the data and store the outcome in the pixelArray
void render()
{
	struct ray tempRay;
	struct ray tempRayA;
	struct ray tempRayB;
	struct ray tempRayC;
	struct ray tempRayD;
	struct ray tempRayE;
	struct ray tempRayF;
	struct ray tempRayG;
	struct ray tempRayH;
	
	struct RGBColor3f **pixelArray = 0;
	
	struct RGBColor3f tempRGBColor3f;
	struct RGBColor3f tempRGBColor3fA;
	struct RGBColor3f tempRGBColor3fB;
	struct RGBColor3f tempRGBColor3fC;
	struct RGBColor3f tempRGBColor3fD;
	struct RGBColor3f tempRGBColor3fE;
	struct RGBColor3f tempRGBColor3fF;
	struct RGBColor3f tempRGBColor3fG;
	struct RGBColor3f tempRGBColor3fH;
	
	struct ray rayValue;
	
	pixelArray = new struct RGBColor3f *[width];
	pixelArray = (struct RGBColor3f **) malloc(width * sizeof(struct RGBColor3f));
	for(int k = 0; k < width; k++)
	{
		pixelArray[k] = new struct RGBColor3f[height];
		pixelArray[k] = (struct RGBColor3f *) malloc(height * sizeof(struct RGBColor3f));
	}
	cameraCoordinates();
	/*------------------Log Code------------------//
	printf("Loging pixelArray\n");
	FILE *logPxl = fopen("logPixel.txt", "at");
    if (!logPxl) logPxl = fopen("logPixel.txt", "wt");
	/*------------------Log Code------------------*/

	for (int i = 0; i < height; i++) 
	{
		for (int j = 0; j < width; j++)
		{
			tempRay = compute(i, j);                           //////////
			tempRayA = compute(i-0.5,j+0.5);
			tempRayB = compute(i+0.5,j+0.5);
			tempRayC = compute(i+0.5,j-0.5);
			tempRayD = compute(i-0.5,j-0.5);
			tempRayE = compute(i,j+0.5);
			tempRayF = compute(i+0.5,j);
			tempRayG = compute(i-0.5,j);
			tempRayH = compute(i,j-0.5);
			tempRGBColor3f = trace(tempRay,  0);
			tempRGBColor3fA = trace(tempRayA, 0);
			tempRGBColor3fB = trace(tempRayB, 0);
			tempRGBColor3fC = trace(tempRayC, 0);
			tempRGBColor3fD = trace(tempRayD, 0);
			tempRGBColor3fE = trace(tempRayE, 0);
			tempRGBColor3fF = trace(tempRayF, 0);
			tempRGBColor3fG = trace(tempRayG, 0);
			tempRGBColor3fH = trace(tempRayH, 0);
			
			tempRGBColor3f.R = tempRGBColor3f.R/4 + (tempRGBColor3fA.R + tempRGBColor3fB.R +tempRGBColor3fC.R + tempRGBColor3fD.R)/16
							+(tempRGBColor3fE.R + tempRGBColor3fF.R + tempRGBColor3fG.R + tempRGBColor3fH.R)/8;
			tempRGBColor3f.G = tempRGBColor3f.G/4 + (tempRGBColor3fA.G + tempRGBColor3fB.G +tempRGBColor3fC.G + tempRGBColor3fD.G)/16
							+(tempRGBColor3fE.G + tempRGBColor3fF.G + tempRGBColor3fG.G + tempRGBColor3fH.G)/8;
			tempRGBColor3f.B = tempRGBColor3f.B/4 + (tempRGBColor3fA.B + tempRGBColor3fB.B +tempRGBColor3fC.B + tempRGBColor3fD.B)/16
							+(tempRGBColor3fE.B + tempRGBColor3fF.B + tempRGBColor3fG.B + tempRGBColor3fH.B)/8;
			if(tempRGBColor3f.R > 1) 
				tempRGBColor3f.R = 1.0;
			if(tempRGBColor3f.G > 1)
				tempRGBColor3f.G = 1.0;		
			if(tempRGBColor3f.B > 1)	
				tempRGBColor3f.B = 1.0;
			if(tempRGBColor3f.R < 0) 
				tempRGBColor3f.R = 0.0;
			if(tempRGBColor3f.G < 0)
				tempRGBColor3f.G = 0.0;		
			if(tempRGBColor3f.B < 0)	
				tempRGBColor3f.B = 0.0;	

			pixelArray[i][j] = tempRGBColor3f;
			/*------------------Log Code------------------//
			if (!logPxl) {
				printf("can not open logfile.txt for writing.\n");
				exit (1);  // bail out if we can't log
			}
			// Insert whatever you want logged here
			fprintf(logPxl,"%1d %1d %1f %1f %1f\n", i, j, pixelArray[i][j].R, pixelArray[i][j].G, pixelArray[i][j].B);
			/*------------------Log Code------------------*/
		}
	}
	/*------------------Log Code------------------//
	fclose(logPxl);
	/*------------------Log Code------------------*/
	
	writePPM(pixelArray);

	
   
    

	for(int k = 0; k < width; k++)
		delete [] pixelArray[k];
	delete [] pixelArray;
}

//debug function to check one specific point i, j
void debug(int i,int j){

	cameraCoordinates();

	struct ray tem = {{0,0,0},{0,0,0}};
	tem = compute(i,j);
	tem.dir = Normalize3(tem.dir);
	
	printf("Ray tem: %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f \n", tem.org.x, tem.org.y, tem.org.z, tem.dir.x, tem.dir.y, tem.dir.z );
	
	struct RGBColor3f locClr = {0,0,0};
	struct RGBColor3f transmitC = {0,0,0};
	struct RGBColor3f reflectC = {0,0,0};
	struct RGBColor3f tempcolor = {0,0,0};
	struct Vector3f objP = {0,0,0};
	struct Vector3f normal = {0,0,0};
	int status = -1;
    float tempka = 0;
	float tempkd = 0;
	float tempks= 0;
	float tempshine= 0;
	float tempkr= 0;
	float tempkt= 0;
	float tempior= 0;
	
	tem.dir = Normalize3(tem.dir);

	
	objP = intersect(tem, &status);
	
	printf("Intersect: %4.2f %4.2f %4.2f\n", objP.x, objP.y, objP.z);
	normal.x = global_normal.x;
	normal.y = global_normal.y;
	normal.z = global_normal.z;
	normal = Normalize3(normal);
	printf("Normal: %4.2f %4.2f %4.2f\n", normal.x, normal.y, normal.z);


	if(status == -1)
		status = -1;
	else
	{
		if(strcmp( PigmentArray[ObjectArray[status].numP].name,"solid")==0)
		{
            tempcolor.R = PigmentArray[ObjectArray[status].numP].c1.R;
			tempcolor.G = PigmentArray[ObjectArray[status].numP].c1.G;
			tempcolor.B = PigmentArray[ObjectArray[status].numP].c1.B;
		} 
		else if (strcmp( PigmentArray[ObjectArray[status].numP].name,"checker")==0)
		{
            float x1,y1,z1;
            int x2,y2,z2;
            x1 = (float)objP.x/PigmentArray[ObjectArray[status].numP].s;
            y1 = (float)objP.y/PigmentArray[ObjectArray[status].numP].s;
            z1 = (float)objP.z/PigmentArray[ObjectArray[status].numP].s;
            x2 = floor(x1);y2= floor(y1);z2= floor(z1);
			if ((x2+y2+z2)%2 != 0)
			{
				tempcolor.R = PigmentArray[ObjectArray[status].numP].c1.R;
				tempcolor.G = PigmentArray[ObjectArray[status].numP].c1.G;
				tempcolor.B = PigmentArray[ObjectArray[status].numP].c1.B;
			} else {
				tempcolor.R = PigmentArray[ObjectArray[status].numP].c2.R;
				tempcolor.G = PigmentArray[ObjectArray[status].numP].c2.G;
				tempcolor.B = PigmentArray[ObjectArray[status].numP].c2.B;
            }
        }
		tempka = SurfaceFinishesArray[ObjectArray[status].numS].ka;
		tempkd = SurfaceFinishesArray[ObjectArray[status].numS].kd;
		tempks = SurfaceFinishesArray[ObjectArray[status].numS].ks;
		tempshine = SurfaceFinishesArray[ObjectArray[status].numS].shine;
		tempkr = SurfaceFinishesArray[ObjectArray[status].numS].kr;
		tempkt = SurfaceFinishesArray[ObjectArray[status].numS].kt;
		tempior = SurfaceFinishesArray[ObjectArray[status].numS].ior;
	}
	printf("Surface Finish: %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f\n", tempcolor.R, tempcolor.G, tempcolor.B, tempka, tempks, tempshine, tempkr, tempkt, tempior);
	

	//normal = compute_normal(objP);
	locClr.R = tempka * tempcolor.R * LightArray[0].clr.R;
	locClr.G = tempka * tempcolor.G * LightArray[0].clr.G;
	locClr.B = tempka * tempcolor.B * LightArray[0].clr.B;

	
	for(int j = 1; j < numL; j++)
	{   
		if(visible(objP,j,&status))
		{
			printf("Visible is true for %i\n", j);
			struct Vector3f l = { LightArray[j].ver.x-objP.x, LightArray[j].ver.y - objP.y,  LightArray[j].ver.z - objP.z};
			
			float d = (float)sqrt(Dot3(l, l));
			d =  LightArray[j].attenuationA + d * LightArray[j].attenuationB + d * d * LightArray[j].attenuationC;

			l = Normalize3(l);
			struct Vector3f v = { camera.x-objP.x, camera.y - objP.y,  camera.z - objP.z};
			v = Normalize3(v);
			struct Vector3f h = Normalize3 ( addv( l, v));
			h = Normalize3(h);
			
			locClr.R = locClr.R + LightArray[j].clr.R * (tempcolor.R * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;
            locClr.G = locClr.G + LightArray[j].clr.G * (tempcolor.G * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;
			locClr.B = locClr.B + LightArray[j].clr.B * (tempcolor.B * tempkd * max(0, Dot3(normal, l)) + tempks * pow(max(0,Dot3(normal, h)),tempshine))/d;
		}
	}
	printf("Local Color: %4.2f %4.2f %4.2f\n", locClr.R, locClr.G, locClr.B);
}

//main function to prompt the user for the file name and trigger the ray trace calculation
int main()
{
	try
	{
		char filename[80];
		printf("Please enter file name: ");
		scanf ("%s",filename);
		
		readfile(filename);

		printf("Back in main the input is:\n");
		/*---------------------Data---------------------*/
		printf("%s\n", outfileName);
		printf("%d %d\n", width, height);
		printf("%4.2f %4.2f %4.2f\n", camera.x, camera.y, camera.z);
		printf("%4.2f %4.2f %4.2f\n", at.x, at.y, at.z);
		printf("%4.2f %4.2f %4.2f\n", up.x, up.y, up.z);
		printf("%d\n", fovy);
		printf(" %d\n", numL);

		for(int i = 0; i < numL; i++)
		{
			printf("%4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f\n", LightArray[i].ver.x, LightArray[i].ver.y, LightArray[i].ver.z, 
				LightArray[i].clr.R, LightArray[i].clr.G, LightArray[i].clr.B, 
				LightArray[i].attenuationA, LightArray[i].attenuationB, LightArray[i].attenuationC);
		}
		printf("%d\n", numP);
		for(int i = 0; i < numP; i++)
		{
			if(strcmp(PigmentArray[i].name,"solid")==0)
			{
				printf("%s %4.2f %4.2f %4.2f, %4.2f, %4.2f, %4.2f, %4.2f\n", PigmentArray[i].name, PigmentArray[i].c1.R, PigmentArray[i].c1.G, PigmentArray[i].c1.B,
				PigmentArray[i].c2.R, PigmentArray[i].c2.G, PigmentArray[i].c2.B, PigmentArray[i].s);
			}
			else if(strcmp(PigmentArray[i].name,"checker")==0)
			{
				printf("%s %4.2f %4.2f %4.2f, %4.2f, %4.2f, %4.2f, %4.2\n", PigmentArray[i].name, PigmentArray[i].c1.R, PigmentArray[i].c1.G, PigmentArray[i].c1.B,
				PigmentArray[i].c2.R, PigmentArray[i].c2.G, PigmentArray[i].c2.B, PigmentArray[i].s);
			}
		}
		printf("numF: %d\n", numF);
		for(int i = 0; i < numF; i++)
		{
			printf("%4.2f %4.2f %4.2f %4.2f %4.2f %4.2f %4.2f\n", SurfaceFinishesArray[i].ka, SurfaceFinishesArray[i].kd, SurfaceFinishesArray[i].ks, 
				SurfaceFinishesArray[i].shine, SurfaceFinishesArray[i].kr, SurfaceFinishesArray[i].kt, SurfaceFinishesArray[i].ior);
		}
		printf("numT %d\n", numT);
		for(int i = 0; i < numT; i++)
		{
			printf("%s %4.2f %4.2f %4.2f\n", TransformationArray[i].name, TransformationArray[i].vec.x, TransformationArray[i].vec.y, TransformationArray[i].vec.z);
		}
		printf("numO: %d\n", numO);
		polyIndex = 0;
		for(int i = 0; i < numO; i++)
		{
			printf("%d %d %d %s", ObjectArray[i].numP, ObjectArray[i].numS, ObjectArray[i].numT, ObjectArray[i].name);
			if(strcmp( ObjectArray[i].name,"sphere")==0)
			{
				printf(" %4.2f %4.2f %4.2f %4.2f\n", SphereArray[i].x, SphereArray[i].y, SphereArray[i].z, SphereArray[i].r);
			}
			else if(strcmp(ObjectArray[i].name,"polyhedron")==0)
			{
				printf(" %d\n", ObjectArray[i].numPoly);
				for(int j=0; j < ObjectArray[i].numPoly; j++)
				{
					printf("%4.2f %4.2f %4.2f %4.2f\n",  PolyhedronArray[polyIndex].coefA, PolyhedronArray[polyIndex].coefB,  PolyhedronArray[polyIndex].coefC,  PolyhedronArray[polyIndex].coefD);
					polyIndex++;
				}
			}
			else if(strcmp(ObjectArray[i].name,"trianglemesh")==0)
			{
				long k, l;
				printf("%s\n", TrianglemeshArray[i].file);
				printf("%d\n", &TrianglemeshArray[i].N);
				printf("%d\n", &TrianglemeshArray[i].M);
				for (k = 0; k < TrianglemeshArray[i].N; k++)
				{
					printf("%s %f %f %f\n", TriangleVArray[k].v, TriangleVArray[k].ver.x, TriangleVArray[k].ver.y, TriangleVArray[k].ver.z);
				}
				for (l = 0; l < TrianglemeshArray[i].M; l++)
				{
					printf("%s %ld %ld %ld\n", TriangleFArray[l].f, TriangleFArray[l].vertex0, TriangleFArray[l].vertex1, TriangleFArray[l].vertex2);
				}
			}
		}


		/*---------------------Data---------------------*/

		render();
		//debug(20, 280);

	}
	catch(...)
	{
		printf("Catching an Exception\n");
	}
    return 0;
}
				</pre>
			  </div>
			</div>
			<div class="panelcollapsed">
			  <h3>Ray Tracer Algorithm Header</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
/* Raytrace header file*/


#ifndef __RAYTRACE_H

#define __RAYTRACE_H
#define PI 3.14159265


#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib> // for exit function
#include <sstream>
#include <math.h>

#include "Def.h"

using namespace std;

const int DEPTH = 4;
const int MAX_LIGHT = 20;
const int MAX_PIGMENT = 25;
const int MAX_SURFACE = 25;
const int MAX_TRANFORM = 25;
const int MAX_OBJECT = 100;
const int MAX_POLY_SUR = 20;
const int MAX_TRI_VER = 20;
const float EPS = 0.01;

//veriables

char outfileName[100];
int width, height;
int fovy, numL, numP, numF, numO, numT, numFaces;
int polyIndex = 0;
struct Vector3f global_normal;
int numTransform[MAX_TRANFORM] = {0};

struct RGBColor3f BGColor = {0.5,0.5,0.5};
struct Vector3f camera, at, up, CX, CY, CZ;
struct lightSRC LightArray[MAX_LIGHT] = {0};
struct pigmentSRC PigmentArray[MAX_PIGMENT] = {0};
struct surfaceFinishSRC SurfaceFinishesArray[MAX_SURFACE] = {0};
struct transformationSRC TransformationArray[MAX_TRANFORM] = {0};

struct objectSRC ObjectArray[MAX_OBJECT] = {0};
struct sphere SphereArray[MAX_OBJECT] = {0};
struct polyhedron PolyhedronArray[MAX_POLY_SUR] = {0};
struct trianglemesh TrianglemeshArray[MAX_TRI_VER] = {0};

struct Vector3f p1;
struct Vector3f p2;
struct Vector3f ave_vector;
struct triangleVector *TriangleVArray;
struct triangleFaces *TriangleFArray;






#endif // __RAYTRACE_H
				</pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=300;height=300" href="./doc/content/Images/AdvancedGraphics_test1.jpg" title="Random Search">See Image 1  </a>
			<a rel="shadowbox;width=300;height=300" href="./doc/content/Images/AdvancedGraphics_test2.jpg" title="Random Search">See Image 2  </a>
			<a rel="shadowbox;width=300;height=300" href="./doc/content/Images/AdvancedGraphics_test3.jpg" title="Random Search">See Image 3  </a>
			<a rel="shadowbox;width=300;height=300" href="./doc/content/Images/AdvancedGraphics_test5.jpg" title="Random Search">See Image 4  </a>
			</h4>
			
			</p>
        </div>
        <div class="article" id="AI">
			<h2><span>Artificial Intelligence</span></h2>
			<div class="clr"></div>
			<p>
			<div class="panelcollapsed">
			  <h3>Random Search Algorithm</h3>
			  <div class="panelcontent">
				 <pre class="brush: java;" style="overflow: hidden;">
  //**************************************
  //A method that performs a random first search algorithm
  //it picks which way to go randomly.
  //**************************************
  public static void random(int GBx, int GBy) {

	int newGBx;
	int newGBy;
	 int myMove = -1;
	 removeGhostbuster(GBx, GBy);
	 //*** remove ghostbuster from location (gbx, gby)
	if (GBx == ghostX && GBy == ghostY)
	  {
		 System.out.println("You have reached the ghost");
	  }
	  else
	  {      
	  //*** pick a new random board position for the ghostbuster
	   do {
		   newGBx = GBx;
		newGBy = GBy;
		 myMove = randomInt();
			//System.out.println("myMove "+ myMove);
		 //*** pick a random board position
		  if (myMove == 0) {
			newGBy--;
		  }
		  else if (myMove == 1) {
			newGBx--;
		  }
		  else if (myMove == 2) {
			newGBy++;
		  }
		  else{
			newGBx++;
		  }
	   }
	   while (!openSpace(newGBx, newGBy));
	  //*** place  ghostbuster into new location (gbx, gby)
	  moveGhostbuster(newGBx, newGBy);
	  //*** delay updating the screen
	   wait(500);
		 random(newGBx, newGBy);
	}	  
  }
  
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="./doc/content/Videos/ArtificialIntelligence_RandomSearch.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>BreathFirst Search Algorithm</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
  //**************************************
  //A method that performs a Breath first search algorithm
  //using recursion to implement the best possible way to
  //reach the ghost. given the search conditions
  public static void BFS(int GBx, int GBy) throws EmptyQueueException
  {
	 //***Containing the Coordinate that needs to be visited as an object.
	 Coordinate myMove;
	  wait(500);
	  //***Setting the coordinates altredy visited to true
	  visited[GBx][GBy] = true;
	  //***Removing the ghost buster form that coordinate
	  removeGhostbuster(GBx, GBy);
	  //***If the Ghost buster is able to move left, up, right or down
	  //***store it in the queue.
	  if ((openSpace(GBx, GBy - 1)) &&  (!visited[GBx][GBy - 1]))
		{
			BFSqueue.enqueue(new Coordinate(GBx, GBy - 1));
			visited[GBx][GBy - 1] = true;
	  }
	  if ((openSpace(GBx - 1, GBy))  &&  (!visited[GBx - 1][GBy])) 
		{
			BFSqueue.enqueue(new Coordinate(GBx - 1, GBy));
			visited[GBx - 1][GBy] = true;
	  }
	  if ((openSpace(GBx, GBy + 1))  &&  (!visited[GBx][GBy + 1])) 
		{
			BFSqueue.enqueue(new Coordinate(GBx, GBy + 1));
			visited[GBx][GBy + 1] = true;
	  }
	  if ((openSpace(GBx + 1, GBy))  &&  (!visited[GBx + 1][GBy])) 
		{
			BFSqueue.enqueue(new Coordinate(GBx + 1, GBy));
			visited[GBx + 1][GBy] = true;
	  }
		//***if you have reached your goal you are done
		if (GBx == ghostX && GBy == ghostY) 
	   {
		 System.out.println("you have reached the ghost");
		}
		//***else pop off the first coordinate of the queue and move
		//***the ghost buster to that position.
		else if (!BFSqueue.isEmpty())
		{
			myMove = (Coordinate) (BFSqueue.dequeue());
			moveGhostbuster(myMove.getX(), myMove.getY());
			BFS(myMove.getX(), myMove.getY());
		}
		else
		{
			System.out.println("You were unable to find the ghost");
		}
	}
 
				</pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ArtificialIntelligence_Breathfirstsearch.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>DepthFirst Search Algorithm</h3>
				  <div class="panelcontent">
					<pre class="brush: java;" style="overflow: hidden;">
  //**************************************
  //A method that performs a Depth first search algorithm
  //using recursion to implement the best possible way to
  //reach the ghost. given the search conditions.
  public static void DFS(int GBx, int GBy)throws EmptyStackException
   {
	  //***Last move holder. The number that is popped out of the stack
	 int lastMove = -1;
	  //***Setting the coordinates altredy visited to true
	  visited[GBx][GBy] = true;
	  //***Removing the ghost buster form that coordinate
	  removeGhostbuster(GBx, GBy);
	  //***Checking if this coordinare this our goal
	  if (GBx == ghostX && GBy == ghostY)
	   {
		  System.out.println("You have reached the ghost");
		}
		//***If possible move left. Then recurse
	  else if ((openSpace(GBx, GBy - 1)) &&  (!visited[GBx][GBy - 1]))
		{
			moveGhostbuster(GBx, GBy - 1);
			wait(500);
			DFSstack.push(new Integer (WEST));
			DFS(GBx, GBy - 1);	
	  }
		//***If possible move up. Then recurse
	  else if ((openSpace(GBx - 1, GBy))  &&  (!visited[GBx - 1][GBy])) 
		{
			moveGhostbuster(GBx - 1, GBy);
			wait(500);
			DFSstack.push(new Integer (NORTH));
			DFS(GBx - 1, GBy);

	  }
		//***if possible move right. Then recurse
	  else if ((openSpace(GBx, GBy + 1))  &&  (!visited[GBx][GBy + 1])) 
		{
			moveGhostbuster(GBx, GBy + 1);
			wait(500);
			DFSstack.push(new Integer (EAST));
			DFS(GBx, GBy + 1);
	  }
		//***if possible move down. Then recurse
	  else if ((openSpace(GBx + 1, GBy))  &&  (!visited[GBx + 1][GBy])) 
		{
			moveGhostbuster(GBx + 1, GBy);
			wait(500);
			DFSstack.push(new Integer (SOUTH));
			DFS(GBx + 1, GBy);
	  }
		//***If the open stack is empty. Then Back track
		else if (!DFSstack.isEmpty())
		{
			lastMove = ((Integer) DFSstack.pop()).intValue();  //get last move
			if (lastMove == WEST)
			{
				moveGhostbuster(GBx, GBy + 1);
				DFS(GBx, GBy + 1);
			}
			else if (lastMove == NORTH)
			{
				moveGhostbuster(GBx + 1, GBy);
				DFS(GBx + 1, GBy);
			}
			else if (lastMove == EAST)
			{
				moveGhostbuster(GBx, GBy - 1);
				DFS(GBx, GBy - 1);
			}
			else if (lastMove == SOUTH)
			{
				moveGhostbuster(GBx - 1, GBy);
				DFS(GBx - 1, GBy);
			}
		}
		//***Else the goal could not be reached
		else
		{
			System.out.println("A Solution cannot be found");
		}
	}
                            
                    </pre>
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ArtificialIntelligence_Depthfirstsearch.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>AStar Search Algorithm</h3>
				  <div class="panelcontent">
					<pre class="brush: java;" style="overflow: hidden;">
 /*******************************************************************
	 AStar
	 Hardik Bhatt
	 February 2006

	 Performs path-finding on a map using A* algorithm: F = G + H

	 Cost function G must vary based on the type of cell being
	 visited: ocean, desert, forest, hill, mountain.

	 order of preference: forest, desert, hill, mountain, ocean (shallow)
	 avoided:             deep ocean where a cell is sorrounded by water
			  (radius 3 or more)

	 color codes:         ocean = blue = 0,     hill = red = 1,
			  forest = green = 2,   desert = yellow = 3,
			  mountain = white = 4
*/

import java.awt.*;
import javax.swing.*;
import java.applet.*;

//*******************************************************************
//*** implements path-finding through a map using A* algorithm
//***
public class AStar extends JFrame
{
	//*** user preferences for map go here; map dimension is included
	static Map mp;
	static int mapSize = 40;
	static int[] [] mapPlan =
	{
		{2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 1, 4, 1, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 1, 4, 1, 4, 4, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{1, 1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{4, 4, 4, 4, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2},
		{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2}
	};

		//*** Implementing the Astar method
	public static void Astar ()
	{
	AStar star = new AStar ();
	star.setVisible (true);
	PriorityQueue openQueue = new PriorityQueue ();
	Coordinate currentState = new Coordinate (0, 0);
	Coordinate temp = new Coordinate (0, 0);
	int currentX = 0, currentY = 0;
	int priority = 0;

	while (!goalReached (currentX, currentY))
	{
		System.out.println ("Re looped");
		System.out.println ();
		System.out.println ("Front of loop " + currentX + ", " + currentY);
		//*** Going Down
		if ((currentState.getX () + 1) %3c mapPlan.length && (!visited [currentState.getX () + 1] [currentState.getY ()]))
		{
		if (!istoDeep (currentState.getX () + 1, currentState.getY ()))
		{
			//System.out.println ("Astar(): Going Down ");
			temp.setX (currentState.getX () + 1);
			temp.setY (currentState.getY ());
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going Right
		if ((currentState.getY () + 1) %3c mapPlan.length && (!visited [currentState.getX ()] [currentState.getY () + 1]))
		{
		if (!istoDeep (currentState.getX (), currentState.getY () + 1))
		{
			//System.out.println ("Astar(): Going Right ");
			temp.setX (currentState.getX ());
			temp.setY (currentState.getY () + 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going Up
		if ((currentState.getX () - 1) >= 0 && (!visited [currentState.getX () - 1] [currentState.getY ()]))
		{
		if (!istoDeep (currentState.getX () - 1, currentState.getY ()))
		{
			//System.out.println ("Astar(): Going Up ");
			temp.setX (currentState.getX () - 1);
			temp.setY (currentState.getY ());
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going Left
		if ((currentState.getY () - 1) >= 0 && (!visited [currentState.getX ()] [currentState.getY () - 1]))
		{
		if (!istoDeep (currentState.getX (), currentState.getY () - 1))
		{
			//System.out.println ("Astar(): Going Left ");
			temp.setX (currentState.getX ());
			temp.setY (currentState.getY () - 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going South East
		if ((currentState.getX () + 1) %3c mapPlan.length && (currentState.getY () + 1) %3c mapPlan.length && (!visited [currentState.getX () + 1] [currentState.getY () + 1]))
		{
		if (!istoDeep (currentState.getX () + 1, currentState.getY () + 1))
		{
			//System.out.println ("Astar(): Going South East ");
			temp.setX (currentState.getX () + 1);
			temp.setY (currentState.getY () + 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going North West
		if ((currentState.getX () - 1) >= 0 && (currentState.getY () - 1) >= 0 && (!visited [currentState.getX () - 1] [currentState.getY () - 1]))
		{
		if (!istoDeep (currentState.getX () - 1, currentState.getY () - 1))
		{
			//System.out.println ("Astar(): Going North West ");
			temp.setX (currentState.getX () - 1);
			temp.setY (currentState.getY () - 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going North East
		if ((currentState.getX () - 1) >= 0 && (currentState.getY () + 1) %3c mapPlan.length && (!visited [currentState.getX () - 1] [currentState.getY () + 1]))
		{
		if (!istoDeep (currentState.getX () - 1, currentState.getY () + 1))
		{
			//System.out.println ("Astar(): Going North East ");
			temp.setX (currentState.getX () - 1);
			temp.setY (currentState.getY () + 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		//*** Going South West
		if ((currentState.getX () + 1) %3c mapPlan.length && (currentState.getY () - 1) >= 0 && (!visited [currentState.getX () + 1] [currentState.getY () - 1]))
		{
		if (!istoDeep (currentState.getX () + 1, currentState.getY () - 1))
		{
			//System.out.println ("Astar(): Going South West ");
			temp.setX (currentState.getX () + 1);
			temp.setY (currentState.getY () - 1);
			visited [currentX] [currentY] = true;
			priority = H_Manhattan (temp.getX (), temp.getY ()) + G_Path (temp.getX (), temp.getY ());
			System.out.println ("The Priority " + priority);
			openQueue.arrive (temp, priority);
			temp = new Coordinate (0, 0);
		}
		}
		if (!openQueue.isEmpty ())
		{
		Coordinate myMove = new Coordinate (0, 0);
		myMove = (Coordinate) openQueue.leave ();
		currentX = myMove.getX ();
		currentY = myMove.getY ();
		}
		currentState.setX (currentX);
		currentState.setY (currentY);
		System.out.println ();
		//System.out.println ("I move here to " + currentX + ", " + currentY);
		System.out.println ("I move here to " + currentState.getX () + ", " + currentState.getY ());
		//*** display move to a new state by painting cell black
		star.moveToCell (currentX, currentY);
		star.wait (100);
		//*** erase current move and repaint previous cell color
		star.clearCell (currentX, currentY);
		openQueue = new PriorityQueue();

	}
	System.out.println ("Congratulations You have reached the Goal");
	}
}

                    </pre>
            	
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ArtificialIntelligence_AStarSearch.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>EightPuzzle Algorithm</h3>
				  <div class="panelcontent">
					<pre class="brush: java;" style="overflow: hidden;">
/*****************************************************************************/
/*                                                                           */
/* EightPuzzle.java                                                          */
/*                                                                           */
/* Author: Hardik Bhatt                                                      */
/* Date: March 11, 2006                                                      */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/* Instance Variables:                                                       */
/*      currentState - represents the current state you are in               */
/*      goalState - Represents the goal you want to reach from currentState  */
/*      SIZE - the size of the array                                         */
/*      BoardPanel - set up the board                                        */
/*      panelWidth - 100 pixel board cell                                    */
/*      blankX, blankY - The X-Y position of the blank space                 */
/*      depthCounter - The counter of f(n)                                   */
/*                                                                           */
/*                                                                           */
/* Methods:                                                                  */
/*   main - A simple main method that implements the Astar algorithm         */
/*   EightPuzzle - setting up the board a 2D grid                            */
/*   wait - Pause the program for the given amount                           */
/*   findBlank - finds the blank tile in the board                           */
/*   goalReached - checks to see if the goral is reached                     */
/*   evalState1 - Evaluates the state, check the difference in current and   */ 
/*                goal states                                                */
/*   evalState2 - Evaluates the state, check the similarity from the current */
/*                and goal state                                             */
/*   finalState - Used by evalState1 and evalState2 to get the final state   */
/*   move - moves the blank tile to the indicated spot                       */
/*   legalmove - checks to see if you are able to go to a perticular position*/
/*   Astar - performs the Astar routine                                      */
/*   random - performs a random routine                                      */
/*                                                                           */
/*****************************************************************************/

import java.awt.*;
import javax.swing.*;

//***********************************************************************
public class EightPuzzle
	extends JFrame
{
	//*** this is initially the start state
	static char[] [] currentState = {
		{'1', '2', '3'},
		{'4', '5', '6'},
		{'7', '8', ' '}
	};

	//*** the desired goal state
	static char[] [] goalState = {
		{' ', '1', '2'},
		{'4', '5', '3'},
		{'7', '8', '6'}
	};

	public boolean legalmove (char movedir, char[][] state)
	{
	//*** identify where blank is in current configuration
	findBlank (currentState);
	//*** the new blank positions are initialized
	int nblankX = blankX, nblankY = blankY;
	//*** new blank locations are updated based on directions
	showState (state);
	if ((movedir == 'L') && ((nblankY - 1) >= 0))
		return true;
	else if ((movedir == 'R') && ((nblankY + 1) %3c state.length))
		return true;
	else if ((movedir == 'U') && ((nblankX - 1) >= 0))
		return true;
	else if ((movedir == 'D') && ((nblankX + 1) %3c state.length))
		return true;

	return false;
	}

	public void Astar ()
	{
	PriorityQueue openQueue;
	PQLinkEntry closeQueue, front;
	//*** create a new frame and make it visible
	EightPuzzle ePuzz = new EightPuzzle ();
	ePuzz.setVisible (true);
	char temp;
	EPuzzleMove lastMove;
	int MyPriority = 0;

	//*** starting the program
	lastMove = new EPuzzleMove (currentState);
	openQueue = new PriorityQueue ();
	front = new PQLinkEntry(lastMove, -1, null);
	closeQueue = new PQLinkEntry (lastMove, evalState1 (currentState, depthCounter), front);
	System.out.println ("The starting priority " + closeQueue.getPriority ());

	while (!ePuzz.goalReached (currentState))
	{
		depthCounter++;
		ePuzz.wait (200); //waiting
		if (legalmove ('L', currentState))
		{
		
		System.out.println ("Going Left is valid.");
		lastMove = (EPuzzleMove) front.getElement ();
		if (lastMove.getMove () != 'R' || lastMove.getMove () == ' ')
		{
			findBlank (currentState);
			int nblankX = blankX, nblankY = blankY;
			temp = currentState [nblankX] [nblankY - 1];
			currentState [nblankX] [nblankY - 1] = ' ';
			currentState [nblankX] [nblankY] = temp;
			openQueue.arrive (new EPuzzleMove (currentState, 'L'), evalState1 (currentState, depthCounter));
			System.out.println ("The Left priority " + openQueue.getPriority ());
			
			currentState [nblankX] [nblankY - 1] = temp;
			currentState [nblankX] [nblankY] = ' ';
		}
		}
		if (legalmove ('R', currentState))
		{
		System.out.println ("Going Right is valid.");
		lastMove = (EPuzzleMove) front.getElement ();
		if (lastMove.getMove () != 'L' || lastMove.getMove () == ' ')
		{
			findBlank (currentState);
			int nblankX = blankX, nblankY = blankY;
			temp = currentState [nblankX] [nblankY + 1];
			currentState [nblankX] [nblankY + 1] = ' ';
			currentState [nblankX] [nblankY] = temp;
			openQueue.arrive (new EPuzzleMove (currentState, 'R'), evalState1 (currentState, depthCounter));
			System.out.println ("The Right priority " + openQueue.getPriority ());
			
			currentState [nblankX] [nblankY + 1] = temp;
			currentState [nblankX] [nblankY] = ' ';
		}
		}
		if (legalmove ('U', currentState))
		{
		System.out.println ("Going Up is valid.");
		lastMove = (EPuzzleMove) front.getElement ();
		if (lastMove.getMove () != 'D' || lastMove.getMove () == ' ')
		{
			findBlank (currentState);
			int nblankX = blankX, nblankY = blankY;
			temp = currentState [nblankX - 1] [nblankY];
			currentState [nblankX - 1] [nblankY] = ' ';
			currentState [nblankX] [nblankY] = temp;
			openQueue.arrive (new EPuzzleMove (currentState, 'U'), evalState1 (currentState, depthCounter));
			System.out.println ("The Up priority " + openQueue.getPriority ());
			
			currentState [nblankX - 1] [nblankY] = temp;
			currentState [nblankX] [nblankY] = ' ';
		}
		}
		if (legalmove ('D', currentState))
		{
		System.out.println ("Going Down is valid.");
		lastMove = (EPuzzleMove) front.getElement ();
		if (lastMove.getMove () != 'U' || lastMove.getMove () == ' ')
		{
			findBlank (currentState);
			int nblankX = blankX, nblankY = blankY;
			temp = currentState [nblankX + 1] [nblankY];
			currentState [nblankX + 1] [nblankY] = ' ';
			currentState [nblankX] [nblankY] = temp;
			openQueue.arrive (new EPuzzleMove (currentState, 'D'), evalState1 (currentState, depthCounter));
			System.out.println ("The Down priority " + openQueue.getPriority ());
			
			currentState [nblankX + 1] [nblankY] = temp;
			currentState [nblankX] [nblankY] = ' ';
		}
		}
		if (!openQueue.isEmpty ())
		{
		MyPriority = openQueue.getPriority ();
		lastMove = (EPuzzleMove) openQueue.leave ();
		closeQueue = new PQLinkEntry (lastMove, MyPriority, front);
		ePuzz.move (lastMove.getMove ());
		}
		else if (ePuzz.goalReached (currentState))
		{
		System.out.println ("You have reached your goal");
		}
	}
	System.out.println ("You have reached your goal");
	}    
}

                    </pre>
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ArtificialIntelligence_EightPuzzle.flv" title="Random Search">See Video</a></h4>
			</p>		
		</div>
        <div class="article" id="CG">
          <h2><span>Computer Graphics</span></h2>
          <div class="clr"></div>
			<p>
				<div class="panelcollapsed">
				  <h3>Basic 2D Primitives</h3>
				  <div class="panelcontent">
					<pre class="brush: c++;" style="overflow: hidden;">
//---------------------------------------------------------------------//
/* Hardik Bhatt                Assignment 1                    9/29/05 */
/*                                                                     */
/* Discription: A program that originally creates a red diamond a blue */
/*   rectangle and a green triangle and using library functions the    */
/*   purpose of this assignment is to make the colors of the diamond,  */
/*   rectangle and triangle change by using the given operations. And  */
/*   move the positions of the rectangle and diamond by clicking and   */
/*   moving the mouse                                                  */
/*                                                                     */
/*                                                                     */
/*                                                                     */
//---------------------------------------------------------------------//

#include <stdlib.h>			// standard definitions
#include <iostream.h>			// C++ I/O
#include <stdio.h>			// C I/O (for sprintf) 
#include <math.h>			// standard definitions

#include <GL/glut.h>			// GLUT
#include <GL/glu.h>			// GLU
#include <GL/gl.h>			// OpenGL

// global variable declarations

GLint windowHeight, windowWidth;
//boolean used to manage the color changing
GLboolean MY_SWAP = true;
GLboolean MY_TRI = true;

//temperary variable holders
GLfloat REC_X, REC_Y = 0;
GLfloat TRI_X, TRI_Y = 0;
GLfloat DIM_X, DIM_Y = 0;
GLfloat MY_DIR = 0.02;


//-----------------------------------------------------------------------
//	Sets up some default OpenGL values.
//-----------------------------------------------------------------------

void myInit()
{
	glClearColor(0.5, 0.5, 0.5, 1.0);		// background color
	glShadeModel(GL_SMOOTH);		// smooth shading
}

//-----------------------------------------------------------------------
// reshape callback function
//	This is called each time the window is reshaped
//-----------------------------------------------------------------------
void myReshape(int winWidth, int winHeight) 
{

  windowHeight = winHeight;
  windowWidth = winWidth;

  // update projection
  glViewport (0, 0, winWidth,  winHeight);  // update the viewport
  glMatrixMode(GL_PROJECTION);              // update the projection
  glLoadIdentity();               

  gluOrtho2D(-1.0, 1.0, -1.0, 1.0);           // map unit square to viewport
  glMatrixMode(GL_MODELVIEW);

  glutPostRedisplay();                      // request redisplay
  
  
}



//-----------------------------------------------------------------------
// display callback function
//	This is called each time application needs to redraw itself.
//-----------------------------------------------------------------------

void myDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT);       // clear the window
	
	
	if (MY_SWAP == true)
		glColor3f(1.0, 0.0, 0.0);       // set color to red
	else
		glColor3f(0.0, 0.0, 1.0);       // set color to blue
	
	glBegin(GL_POLYGON);            // list the vertices to draw a diamond
	glVertex2f(0.00 + DIM_X, 0.80 + DIM_Y);
	glVertex2f(-0.80 + DIM_X, 0.00 + DIM_Y);
	glVertex2f(0.00 + DIM_X, -0.80 + DIM_Y);
	glVertex2f(0.80 + DIM_X, 0.00 + DIM_Y);
	glEnd();
	
	if (MY_SWAP == true)
		glColor3f(0.0, 0.0, 1.0);       // set color to blue
	else
		glColor3f(1.0, 0.0, 0.0);       // set color to red
	
	glRectf(-0.5 + REC_X, -0.5 + REC_Y, 0.5 + REC_X, 0.5 + REC_Y);  // draw a rectangle (lower left and upper right corners specified)
	
	
	if (MY_TRI == true)
		glColor3f(0.0, 1.0, 0.0);       // set color to green
	else
		glColor3f(0.0, 0.0, 0.0);       // set color to black
	
	glBegin(GL_TRIANGLES);		// Drawing Using Triangles
	glVertex2f( 0.0 + TRI_X, 0.35 + TRI_Y);		// Top
	glVertex2f(-0.2 + TRI_X,-0.17 + TRI_Y);		// Bottom Left
	glVertex2f( 0.2 + TRI_X,-0.17 + TRI_Y);		// Bottom Right
	glEnd();					// Finished Drawing

	glFlush();				// force OpenGL to render now

	glutSwapBuffers();			// swap buffers
}

//-----------------------------------------------------------------------
// keyboard callback function
//	This is called whenever a keyboard key is hit.
//-----------------------------------------------------------------------

void myKeyboard(unsigned char c, int x, int y)
{
	switch (c)
	{
	  case 'q':
		  exit(0);			// exit
	  break;
	}
	glutPostRedisplay();		// request redisplay
}

void mySpecialKeys (int key, int x, int y)
{
	//if the ctrl key is pressed the triangle moves if not
	//the rectangle will move using the arrow keys
	if (glutGetModifiers() == GLUT_ACTIVE_CTRL)
	{
		switch(key)		//mainting the movement key fot the triangle
		{
			case GLUT_KEY_LEFT:		
				TRI_X = TRI_X - MY_DIR;
			break;
			case GLUT_KEY_RIGHT:
				TRI_X = TRI_X + MY_DIR;
			break;
			case GLUT_KEY_UP:
				TRI_Y = TRI_Y + MY_DIR;
			break;
			case GLUT_KEY_DOWN:
				TRI_Y = TRI_Y - MY_DIR;
			break;
		}	//end switch statement
	}	//end if statement
	else
	{
		switch(key)		//mainting the movement key fot the rectangle
		{
			case GLUT_KEY_LEFT:
				REC_X	= REC_X - MY_DIR;
			break;
			case GLUT_KEY_RIGHT:
				REC_X	= REC_X + MY_DIR;
			break;
			case GLUT_KEY_UP:
				REC_Y	= REC_Y + MY_DIR;
			break;
			case GLUT_KEY_DOWN:
				REC_Y	= REC_Y - MY_DIR;
			break;
		}	//end switch statement
	}	//end else statement
	glutPostRedisplay();		// request redisplay
}

void myMotionRec(int x, int y)
{
	//maintaning the x and y coordinate of the mouse to move the
	//rectangle respectively
	REC_X = ((x - 200.0)/200.0);
	REC_Y = (((400.0 - y) - 200.0)/200.);
	glutPostRedisplay();		// request redisplay
}

void myMotionDim(int x, int y)
{
	//maintaning the x and y coordinate of the mouse to move the
	//diamond respectively
	DIM_X = ((x - 200.0)/200.0);
	DIM_Y = (((400.0 - y)-200.0)/200.0);
	glutPostRedisplay();			// request redisplay
}


// called if mouse click
void myMouse(int b, int s, int x, int y) 
{
	switch  ( b ) 
	{    // b indicates the button
	case GLUT_LEFT_BUTTON:
		if (s == GLUT_DOWN)      // button pressed
		{
			MY_SWAP = !MY_SWAP;
			glutMotionFunc(myMotionRec);
		}
		else if (s == GLUT_UP)   // button released
		{
			MY_SWAP = MY_SWAP;
		}
	break;
		
	case GLUT_RIGHT_BUTTON:
		if (s == GLUT_DOWN)      // button pressed
		{
			MY_TRI = !MY_TRI;
			glutMotionFunc(myMotionDim);
		}
		else if (s == GLUT_UP)   // button released
		{
			MY_TRI = !MY_TRI;
		}
		break;
	}	//end switch statement
	glutPostRedisplay();			  // request redisplay
}



// called if timer event occurs
void myTimeOut(int id) 
{
	// advance the state of animation incrementally
	glutPostRedisplay();			  // request redisplay
	glutTimerFunc(10000, myTimeOut, 0);  // request next timer event
	MY_SWAP = !MY_SWAP;
}



//-----------------------------------------------------------------------
// main program
//	
//-----------------------------------------------------------------------
int main(int argc, char **argv)
{
					
	glutInit(&argc, argv);   //initialize glut and gl
	glutInitDisplayMode(		
		GLUT_DOUBLE |		// double buffering
		GLUT_RGB );		    // RGB color mode

	glutInitWindowSize(400, 400);   // 400x400 window
	glutInitWindowPosition(0,0);    // upper left
	glutCreateWindow("My First OpenGL Program: Assignment 1"); 	// create the window

	//register callbacks
	glutDisplayFunc(myDisplay);		//  call myDisplay to redraw window
	//keyboard entries
	glutKeyboardFunc(myKeyboard);   // call myKeyboard when key is hit
	glutSpecialFunc(mySpecialKeys); //call mySpecialKeys when key is hit
	
	//Mouse entries
	glutReshapeFunc(myReshape);     // call myReshape if window is resized
	glutMouseFunc(myMouse);         // call in mouse event
	glutMotionFunc(NULL);

	//OpenGL Timer
	glutTimerFunc(10000, myTimeOut, 0);

	myInit();				// our own initializations

	glutMainLoop();			// pass control to GLUT, start it running

	return 0;               // ANSI C expects this
}
                    </pre>
				  </div>
				</div>
				 <h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ComputerGraphics_Assignment1.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>Wired World</h3>
				  <div class="panelcontent">
					<pre class="brush: c++;" style="overflow: hidden;">
//---------------------------------------------------------------------//
/* Hardik Bhatt                Assignment 3                            */
/*                                                                     */
/* Discription:  This assignment dealt with creating a 200 by 200 world*/
/* where there are 2 alien ships initially facing opposite directions  */
/* and the scenario is that one ship is moving backwards inside the    */
/* world. By clicking of the left mouse button, your view will change  */
/* from one ship to another and by checking on the 's' or 'd' and the  */
/* 'k' or 'l' keys you can translate or rotate the alien ship          */
/* depending on your view.                                             */
/*                                                                     */
/*                                                                     */
/*                                                                     */
/*                                                                     */
//---------------------------------------------------------------------//

#include <stdlib.h>			// standard definitions
#include <iostream.h>			// C++ I/O
#include <stdio.h>			// C I/O (for sprintf) 
#include <math.h>			// standard definitions

#include <GL/glut.h>			// GLUT
#include <GL/glu.h>			// GLU
#include <GL/gl.h>			// OpenGL

#define FOVY 60

#define NO_SHIPS 2           /*number of ships */
#define NO_CLOUDS 8          /*number of clouds */
#define SHIP_TVEL_INC 2      /*incremen/decrement amounts for ship velocities */
#define SHIP_TVEL_DEC -2
#define SHIP_RVEL_INC 0.2
#define SHIP_RVEL_DEC -0.2
#define INNER 1              /*inner radius of torus */
#define OUTER 4              /*outer radius of torus */ 
#define SPHERERADIUS 10            /*radius of sphere */
#define NEAR 1               /*clipping plane near and far */
#define FAR 10000
GLboolean MYPAUSE = false; //boolean that keep track of pause of game
GLboolean MYTRACE = false;

/* window dimensi0ns */
int wh=300;
int ww=400;

GLfloat Radious = 3.141598/180;
/* parameters for drawing sphere and torus */
GLint NO_STACKS=20;
GLint NO_SLICES=20;
GLint NO_SIDES=20;
GLint NO_RINGS=20;

/*variable that stores which ship is in use*/
GLint Ship = 0;

GLfloat ship_color[4]={1.0,0.627,0.478};  /*color of a ship */
GLfloat ground_color[4]={0.0, 1.0, 0.0}; 
 
/* The ground should be located at z=0 plane, you can use (0,0,0) as the lower left corner and (200, 200, 0) as the upper right corner. */

/*several initializations */
/* cloud coordinates(x,y,z) for each cloud */ 
GLfloat cloud_coords[NO_CLOUDS][3]={{30, 30, 30},
			   {30, 170, 15},
			   {80, 110, 25},
			   {70,  60, 12},
			   {90, 150, 13},
			   {120,  80, 17},
			   {150,  40, 15},
			   {160, 170, 22}};

/*cloud colors(rgb) for each cloud */
GLfloat cloud_colors[NO_CLOUDS][3]={{0.30, 0.30, 0.30},
			   {1.00, 0.00, 0.00},
			   {0.00, 1.00, 0.00},
			   {0.00, 0.00, 1.00},
			   {1.00, 1.00, 0.00},
			   {1.00, 0.00, 1.00},
			   {0.00, 1.00, 1.00},
			   {1.00, 1.00, 1.00}};
					 
/*ship coordinates for all ships, (x,y,z) for each ship*/
GLfloat ship_coords[NO_SHIPS][3]={{100.0,10.0,10.0},
			  {105.0,0.0,15.0}};


/*velocites (translational and rotational) for each ship */
GLfloat ship_velocities[NO_SHIPS][2]={{0.0,0.0},
					 {-2.0,0.0}};


/*heading initializations for each ship */
GLfloat ship_headings[NO_SHIPS]={0.0, 180.0};

/* initial viewer location and At location*/
static GLdouble viewer[]= {0.0, 0.0, 0.0}; 
static GLdouble at[]= {0.0, 0.0, 0.0};

void myInit();
void myReshape(int ww, int wh);
void myDisplay();
void myKeyboard(unsigned char c, int x, int y);
void myMouse(int btn, int state, int x, int y);
void myTimeOut(int id);

//-----------------------------------------------------------------------
// main program
//	
//-----------------------------------------------------------------------
int main(int argc, char **argv)
{
					
	glutInit(&argc, argv);   //initialize glut and gl
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(ww, wh);   // window
	glutInitWindowPosition(200,200);    // upper left
	glutCreateWindow("My OpenGL Program: Assignment 4"); 	// create the window

	//register callbacks
	glutReshapeFunc(myReshape);     // call myReshape if window is resized
	glutDisplayFunc(myDisplay);		//  call myDisplay to redraw window
	//keyboard entries
	glutKeyboardFunc(myKeyboard);   // call myKeyboard when key is hit
	glutMouseFunc(myMouse);         // call in mouse event
	
	glEnable(GL_DEPTH_TEST);
	glutTimerFunc(100, myTimeOut, 0);
	
	myInit();				// our own initializations

	glutMainLoop();			// pass control to GLUT, start it running
	return 0;               // ANSI C expects this
}

//-----------------------------------------------------------------------
//	Sets up some default OpenGL values.
//-----------------------------------------------------------------------
void myInit()
{
	glClearColor(0.0, 0.0, 0.0, 1.0);		// background color
	glShadeModel(GL_SMOOTH);		// smooth shading

	viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
	viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
	viewer[2] = ship_coords[Ship][2];

	at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
	at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
	at[2] = viewer[2];

}

//-----------------------------------------------------------------------
// reshape callback function
//	This is called each time the window is reshaped
//-----------------------------------------------------------------------
void myReshape(int ww, int wh) 
{
	
   // update projection
  glViewport (0, 0, ww,  wh);  // update the viewport

/* Use a perspective view */

  glMatrixMode(GL_PROJECTION);              // update the projection
  glLoadIdentity();               

  gluPerspective(FOVY,(GLdouble) ww/wh, NEAR, FAR);
  
  glMatrixMode(GL_MODELVIEW);

  glutPostRedisplay();                      // request redisplay
}


//-----------------------------------------------------------------------
// display callback function
//	This is called each time application needs to redraw itself.
//-----------------------------------------------------------------------
void myDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);       // clear the window
	int i, j;
	/* Update viewer position in modelview matrix */

	glLoadIdentity();
	gluLookAt(viewer[0], viewer[1], viewer[2], at[0], at[1], at[2], 0.0, 0.0, 1.0);

	/*glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);



	glLightfv(GL_LIGHT0, GL_POSITION, light_coords[0]);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient[0]);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse[0]);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular[0]);
	glEnable(GL_LIGHT0);
	
		glLightfv(GL_LIGHT1, GL_POSITION, light_coords[1]);
		glLightfv(GL_LIGHT1, GL_AMBIENT, light_ambient[1]);
		glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse[1]);
	glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular[1]);*/
	
	for (i =0; i < NO_CLOUDS; i++)
	{
		
		glPushMatrix();
		glColor3f(cloud_coords[i][0], cloud_coords[i][1], cloud_coords[i][2]);
		glTranslatef(cloud_coords[i][0], cloud_coords[i][1], cloud_coords[i][2]);
		glutWireSphere(SPHERERADIUS, NO_STACKS, NO_SLICES); // parameters: radius, number of slices (longitude), no stacks (latitude)
		glPopMatrix();
	}

	for (j =0; j < NO_SHIPS; j++)
	{
		glPushMatrix();
		glTranslatef(ship_coords[j][0], ship_coords[j][1], ship_coords[j][2]);
		glutWireTorus(INNER, OUTER, NO_SIDES, NO_RINGS); // inner radius, outer radis, no sides, no rings
		glRotatef(90, 0, 1, 0);
		glutWireTorus(INNER, OUTER, NO_SIDES, NO_RINGS); // inner radius, outer radis, no sides, no rings
		glPopMatrix();
	}

	glColor3f(ground_color[0], ground_color[1], ground_color[2]);
	glRectf(0.0, 0.0, 200.0, 200.0);
	glFlush();				// force OpenGL to render now
	glutSwapBuffers();			// swap buffers

}

//-----------------------------------------------------------------------
// keyboard callback function
//	This is called whenever a keyboard key is hit.
//-----------------------------------------------------------------------

void myKeyboard(unsigned char c, int x, int y)
{
	switch (c)
	{
	  case 'q':
		  exit(0);			// exit
		  break;
	  case 'a':
		  ship_velocities[Ship][0] += SHIP_TVEL_INC;    //increase by constant amount
		  break;
	  case 's':
		  ship_velocities[Ship][0] += SHIP_TVEL_DEC;    //decrease by constant amount
		  break;
	  case 'l':
		  ship_velocities[Ship][1] += SHIP_RVEL_INC;    //increase the ship's rightward rotation
		  break;
	  case 'k':
		  ship_velocities[Ship][1] += SHIP_RVEL_DEC;    //decrease the ship's rightward rotation
		  break;
	}
	glutPostRedisplay();		// request redisplay
}

//-----------------------------------------------------------------------
// mouse callback function
//	
//-----------------------------------------------------------------------
void myMouse(int btn, int state, int x, int y)
{
	if ((btn == GLUT_LEFT_BUTTON)&&(state == GLUT_DOWN))
	{
	   if(Ship == 0)
	   {
		   Ship = 1;
		   viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
		   viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
		   viewer[2] = ship_coords[Ship][2];
		   at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		   at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		   at[2] = viewer[2];

	   }
	   else
	   {
		   Ship = 0;
		   viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
		   viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
		   viewer[2] = ship_coords[Ship][2];
		   at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		   at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		   at[2] = viewer[2];

	   }
	}
	
	if ((btn == GLUT_MIDDLE_BUTTON) && (state == GLUT_DOWN) && MYPAUSE == false)
	{
		glutIdleFunc(NULL);
		MYPAUSE = true;
	}
	else if ((btn == GLUT_MIDDLE_BUTTON) && (state == GLUT_DOWN) && MYPAUSE == true)
	{
		glutTimerFunc(100, myTimeOut, 0);
		MYPAUSE = false;
	}

	if ((btn == GLUT_RIGHT_BUTTON) && (state == GLUT_DOWN))
	{
		glutIdleFunc(NULL);
		MYTRACE = true;
	}


	glutPostRedisplay();		// request redisplay
}

//-----------------------------------------------------------------------
// idle callback function
//	
//-----------------------------------------------------------------------

void myTimeOut(int id) 
{

	if (MYPAUSE == false || MYTRACE == true)
	{
		//translational
		ship_coords[0][0] += ship_velocities[0][0]*sin(ship_headings[0]*Radious);
		ship_coords[0][1] += ship_velocities[0][0]*cos(ship_headings[0]*Radious);

		ship_coords[1][0] += ship_velocities[1][0]*sin(ship_headings[1]*Radious);
		ship_coords[1][1] += ship_velocities[1][0]*cos(ship_headings[1]*Radious);

	

		ship_coords[Ship][0] += ship_velocities[Ship][1]*sin(ship_headings[Ship]*Radious);
		ship_headings[Ship] += ship_velocities[Ship][1];
		ship_coords[Ship][1] += ship_velocities[Ship][1]*cos(ship_headings[Ship]*Radious);
		ship_headings[Ship] += ship_velocities[Ship][1];

		viewer[0] = ship_coords[Ship][0] + OUTER*sin(ship_headings[Ship]*Radious);
		viewer[1] = ship_coords[Ship][1] + OUTER*cos(ship_headings[Ship]*Radious);
		viewer[2] = ship_coords[Ship][2];
		at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		at[2] = viewer[2];



		MYTRACE = false;
	}

	// advance the state of animation incrementally
	glutPostRedisplay();			  // request redisplay
	glutTimerFunc(100, myTimeOut, 0);  // request next timer event
}
                    </pre>
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ComputerGraphics_Assignment3.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>Solid World</h3>
				  <div class="panelcontent">
					<pre class="brush: c++;" style="overflow: hidden;">
//---------------------------------------------------------------------//
/* Hardik Bhatt                Assignment 4                            */
/*                                                                     */
/* Discription:  Essentially similar to the previous however this time */
/* instead of a wire world the world is using solid objects, Fog and   */
/* shadows.                                                            */
/*                                                                     */
/*                                                                     */
/*                                                                     */
/*                                                                     */
//---------------------------------------------------------------------//

#include <stdlib.h>			// standard definitions
#include <iostream.h>			// C++ I/O
#include <stdio.h>			// C I/O (for sprintf) 
#include <math.h>			// standard definitions

#include <GL/glut.h>			// GLUT
#include <GL/glu.h>			// GLU
#include <GL/gl.h>			// OpenGL

#define FOVY 60

#define NO_SHIPS 2           /*number of ships */
#define NO_CLOUDS 8          /*number of clouds */
#define SHIP_TVEL_INC 2      /*incremen/decrement amounts for ship velocities */
#define SHIP_TVEL_DEC -2
#define SHIP_RVEL_INC 0.2
#define SHIP_RVEL_DEC -0.2
#define INNER 1              /*inner radius of torus */
#define OUTER 4              /*outer radius of torus */ 
#define SPHERERADIUS 10            /*radius of sphere */
#define NEAR 1               /*clipping plane near and far */
#define FAR 10000
#define NO_LIGHTS 2
GLboolean MYPAUSE = false; //boolean that keep track of pause of game
GLboolean MYTRACE = false;

/* window dimensi0ns */
int wh=300;
int ww=400;

GLfloat Radious = 3.141598/180;
/* parameters for drawing sphere and torus */
GLint NO_STACKS=20;
GLint NO_SLICES=20;
GLint NO_SIDES=20;
GLint NO_RINGS=20;

/*variable that stores which ship is in use*/
GLint Ship = 0;

GLfloat ship_color[4]={1.0,0.627,0.478};  /*color of a ship */
GLfloat ground_color[4]={0.0, 1.0, 0.0}; 
 
/* The ground should be located at z=0 plane, you can use (0,0,0) as the lower left corner and (200, 200, 0) as the upper right corner. */

/*several initializations */
/* cloud coordinates(x,y,z) for each cloud */ 
GLfloat cloud_coords[NO_CLOUDS][3]={{30, 30, 30},
			   {30, 170, 15},
			   {80, 110, 25},
			   {70,  60, 12},
			   {90, 150, 13},
			   {120,  80, 17},
			   {150,  40, 15},
			   {160, 170, 22}};

/*cloud colors(rgb) for each cloud */
GLfloat cloud_colors[NO_CLOUDS][3]={{0.30, 0.30, 0.30},
			   {1.00, 0.00, 0.00},
			   {0.00, 1.00, 0.00},
			   {0.00, 0.00, 1.00},
			   {1.00, 1.00, 0.00},
			   {1.00, 0.00, 1.00},
			   {0.00, 1.00, 1.00},
			   {1.00, 1.00, 1.00}};
					 
/*ship coordinates for all ships, (x,y,z) for each ship*/
GLfloat ship_coords[NO_SHIPS][3]={{100.0,10.0,10.0},
			  {105.0,0.0,15.0}};


/*velocites (translational and rotational) for each ship */
GLfloat ship_velocities[NO_SHIPS][2]={{0.0,0.0},
					 {-2.0,0.0}};


/*heading initializations for each ship */
GLfloat ship_headings[NO_SHIPS]={0.0, 180.0};

/* NEW !!!! Light and Material Related */
/* spcular color component for an object */
GLfloat spec_color[4]={1.0, 1.0, 1.0, 1.0};

GLfloat global_ambient_intensity[4] = {0.2, 0.2, 0.2, 1.0};

/* light coordinates */
GLfloat light_coords[NO_LIGHTS][4]={{0.5,-1.0,1.5,0.0},
						   {-0.5,1.0,0.5,0.0}};

/* light components */
GLfloat light_ambient[NO_LIGHTS][4]={{0.2, 0.2, 0.2, 1.0},
							{0.2, 0.2, 0.2, 1.0}};


GLfloat light_diffuse[NO_LIGHTS][4]={{1.0, 1.0, 1.0, 1.0},
							{1.0, 1.0, 1.0, 1.0}};


GLfloat light_specular[NO_LIGHTS][4]={{2.0, 2.0, 2.0, 1.0},
							 {2.0, 2.0, 2.0, 1.0}}; 

GLfloat fog_color[]={ 0.5, 0.5, 0.5, 1.0}; /* fog color */

GLfloat shininess = 100.0;


/* initial viewer location and At location*/
static GLdouble viewer[]= {0.0, 0.0, 0.0}; 
static GLdouble at[]= {0.0, 0.0, 0.0};

void myInit();
void myReshape(int ww, int wh);
void myDisplay();
void myKeyboard(unsigned char c, int x, int y);
void myMouse(int btn, int state, int x, int y);
void myTimeOut(int id);

//-----------------------------------------------------------------------
// main program
//	
//-----------------------------------------------------------------------
int main(int argc, char **argv)
{
					
	glutInit(&argc, argv);   //initialize glut and gl
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(ww, wh);   // window
	//glutInitWindowPosition(0,0);    // upper left
	glutCreateWindow("My OpenGL Program: Assignment 3"); 	// create the window

	//register callbacks
	glutReshapeFunc(myReshape);     // call myReshape if window is resized
	glutDisplayFunc(myDisplay);		//  call myDisplay to redraw window
	//keyboard entries
	glutKeyboardFunc(myKeyboard);   // call myKeyboard when key is hit
	glutMouseFunc(myMouse);         // call in mouse event
	
	glEnable(GL_DEPTH_TEST);
	glutTimerFunc(100, myTimeOut, 0);
	
	myInit();				// our own initializations

	glutMainLoop();			// pass control to GLUT, start it running
	return 0;               // ANSI C expects this
}

//-----------------------------------------------------------------------
//	Sets up some default OpenGL values, like the viewer and the at for
//  the look at function in myDisplay.
//-----------------------------------------------------------------------
void myInit()
{
	glClearColor(fog_color[0], fog_color[1], fog_color[2], fog_color[3]);		// background color
	glShadeModel(GL_SMOOTH);		// smooth shading

	viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
	viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
	viewer[2] = ship_coords[Ship][2];

	at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
	at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
	at[2] = viewer[2];

}

//-----------------------------------------------------------------------
// reshape callback function
//	This is called each time the window is reshaped
//-----------------------------------------------------------------------
void myReshape(int ww, int wh) 
{
	
   // update projection
  glViewport (0, 0, ww,  wh);  // update the viewport

/* Use a perspective view */

  glMatrixMode(GL_PROJECTION);              // update the projection
  glLoadIdentity();               

  gluPerspective(FOVY,(GLdouble) ww/wh, NEAR, FAR);
  
  glMatrixMode(GL_MODELVIEW);

  glutPostRedisplay();                      // request redisplay
}


//-----------------------------------------------------------------------
// display callback function
//	This is called each time application needs to redraw itself.
// This function draws the ship and the clouds for the world that is made
//-----------------------------------------------------------------------
void myDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);       // clear the window
	int i, j;
	/* Update viewer position in modelview matrix */

	glLoadIdentity();
	gluLookAt(viewer[0], viewer[1], viewer[2], at[0], at[1], at[2], 0.0, 0.0, 1.0);

	
	glFogi(GL_FOG_MODE, GL_EXP);		// Fog Mode
	glFogfv(GL_FOG_COLOR, fog_color);			// Set Fog Color
	glFogf(GL_FOG_DENSITY, 0.01f);				// How Dense Will The Fog Be
	glHint(GL_FOG_HINT, GL_DONT_CARE);			// Fog Hint Value
	glFogf(GL_FOG_START, 1.0f);				// Fog Start Depth
	glFogf(GL_FOG_END, 5.0f);				// Fog End Depth
	glEnable(GL_FOG);					// Enables GL_FOG
	
	glEnable(GL_LIGHTING);
	
	glEnable(GL_LIGHT0);
	glLightfv(GL_LIGHT0, GL_POSITION, light_coords[0]);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient[0]);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse[0]);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular[0]);

	glEnable(GL_LIGHT1);
	glLightfv(GL_LIGHT1, GL_POSITION, light_coords[1]);
	glLightfv(GL_LIGHT1, GL_AMBIENT, light_ambient[1]);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse[1]);
	glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular[1]);

	
	for (i =0; i < NO_CLOUDS; i++)
	{
		glPushMatrix();
		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, cloud_colors[i]);
		glTranslatef(cloud_coords[i][0], cloud_coords[i][1], cloud_coords[i][2]);
		glutSolidSphere(SPHERERADIUS, NO_STACKS, NO_SLICES); // parameters: radius, number of slices (longitude), no stacks (latitude)
		glPopMatrix();
	}

	for (j =0; j < NO_SHIPS; j++)
	{
		glPushMatrix();
		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ship_color);
		glTranslatef(ship_coords[j][0], ship_coords[j][1], ship_coords[j][2]);
		glutSolidTorus(INNER, OUTER, NO_SIDES, NO_RINGS); // inner radius, outer radis, no sides, no rings
		glRotatef(90, 0, 1, 0);
		glutSolidTorus(INNER, OUTER, NO_SIDES, NO_RINGS); // inner radius, outer radis, no sides, no rings
		glPopMatrix();
	}

	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ground_color);
	glRectf(0.0, 0.0, 200.0, 200.0);
	glFlush();				// force OpenGL to render now
	glutSwapBuffers();			// swap buffers

}

//-----------------------------------------------------------------------
// keyboard callback function
//	This is called whenever a keyboard key is hit.
//-----------------------------------------------------------------------

void myKeyboard(unsigned char c, int x, int y)
{
	switch (c)
	{
	  case 'q':
		  exit(0);			// exit
		  break;
	  case 'a':
		  ship_velocities[Ship][0] += SHIP_TVEL_INC;    //increase by constant amount
		  break;
	  case 's':
		  ship_velocities[Ship][0] += SHIP_TVEL_DEC;    //decrease by constant amount
		  break;
	  case 'l':
		  ship_velocities[Ship][1] += SHIP_RVEL_INC;    //increase the ship's rightward rotation
		  break;
	  case 'k':
		  ship_velocities[Ship][1] += SHIP_RVEL_DEC;    //decrease the ship's rightward rotation
		  break;
	}
	glutPostRedisplay();		// request redisplay
}

//-----------------------------------------------------------------------
// mouse callback function
//	
//-----------------------------------------------------------------------
void myMouse(int btn, int state, int x, int y)
{
	if ((btn == GLUT_LEFT_BUTTON)&&(state == GLUT_DOWN))   //changes from ship1 ro ship 2
	{
	   if(Ship == 0)
	   {
		   Ship = 1;
		   viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
		   viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
		   viewer[2] = ship_coords[Ship][2];
		   at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		   at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		   at[2] = viewer[2];

	   }
	   else
	   {
		   Ship = 0;
		   viewer[0] = ship_coords[Ship][0] + OUTER * sin(ship_headings[Ship]*Radious);
		   viewer[1] = ship_coords[Ship][1] + OUTER * cos(ship_headings[Ship]*Radious);
		   viewer[2] = ship_coords[Ship][2];
		   at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		   at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		   at[2] = viewer[2];

	   }
	}
	
	if ((btn == GLUT_MIDDLE_BUTTON) && (state == GLUT_DOWN) && MYPAUSE == false)  //Pause
	{
		glutIdleFunc(NULL);
		MYPAUSE = true;
	}
	else if ((btn == GLUT_MIDDLE_BUTTON) && (state == GLUT_DOWN) && MYPAUSE == true)  //UnPause
	{
		glutTimerFunc(100, myTimeOut, 0);
		MYPAUSE = false;
	}

	if ((btn == GLUT_RIGHT_BUTTON) && (state == GLUT_DOWN))  //Step by step runtime after pause 
	{
		glutIdleFunc(NULL);
		MYTRACE = true;
	}

	glutPostRedisplay();		// request redisplay
}

//-----------------------------------------------------------------------
// myTimeOut callback function
//  essentially runs the whole program by updation the Heading, Location,
//  Velocity, as well as taking care of the Pause feature.
//-----------------------------------------------------------------------

void myTimeOut(int id) 
{

	if (MYPAUSE == false || MYTRACE == true)
	{
		//translational
		ship_coords[0][0] += ship_velocities[0][0]*sin(ship_headings[0]*Radious);
		ship_coords[0][1] += ship_velocities[0][0]*cos(ship_headings[0]*Radious);

		ship_coords[1][0] += ship_velocities[1][0]*sin(ship_headings[1]*Radious);
		ship_coords[1][1] += ship_velocities[1][0]*cos(ship_headings[1]*Radious);

	

		//ship_coords[Ship][0] += ship_velocities[Ship][1]*sin(ship_headings[Ship]*Radious);
		ship_headings[Ship] += ship_velocities[Ship][1];
		//ship_coords[Ship][1] += ship_velocities[Ship][1]*cos(ship_headings[Ship]*Radious);
		ship_headings[Ship] += ship_velocities[Ship][1];

		viewer[0] = ship_coords[Ship][0] + OUTER*sin(ship_headings[Ship]*Radious);
		viewer[1] = ship_coords[Ship][1] + OUTER*cos(ship_headings[Ship]*Radious);
		viewer[2] = ship_coords[Ship][2];
		at[0] = viewer[0] + sin(ship_headings[Ship]*Radious);
		at[1] = viewer[1] + cos(ship_headings[Ship]*Radious);
		at[2] = viewer[2];

		if(MYTRACE == true)
		{
			printf("Ships Heading = %i\n", ship_headings[0]);
			printf("Ships Heading = %i\n", ship_headings[1]);

			printf("Ships Translational Velocity = %i\n", ship_velocities[0][0]);
			printf("Ships Translational Velocity = %i\n", ship_velocities[1][0]);

			printf("Ships Rotational Velocity = %i\n", ship_velocities[0][1]);
			printf("Ships Rotational Velocity = %i\n", ship_velocities[1][1]);

			printf("Ship 1's coordinate x = %i and y = %i\n", ship_coords[0][0],ship_coords[0][1]);
			printf("Ship 2's coordinate x = %i and y = %i\n", ship_coords[1][0],ship_coords[1][1]);

			printf("\n");
		}

		MYTRACE = false;
	}

	// advance the state of animation incrementally
	glutPostRedisplay();			  // request redisplay
	glutTimerFunc(100, myTimeOut, 0);  // request next timer event
}
                    </pre>
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ComputerGraphics_Assignment4.flv" title="Random Search">See Video</a></h4>
			</p>
			<p>
				<div class="panelcollapsed">
				  <h3>3D Bunny</h3>
				  <div class="panelcontent">
					<pre class="brush: c++;" style="overflow: hidden;">
//---------------------------------------------------------------------//
/* Hardik Bhatt                Assignment 5                            */
/*                                                                     */
/* Discription:  This assignment dealt with drawing a bunny using      */
/* vectors and triangle's. The strategy was to essentially draw a      */
/* bunny using triangles, placing them in specific locations in order  */
/* for the bunny to look specifically like a bunny. Later the task was */
/* to translate, rotate, and scale the bunny through right clicking    */
/* the mouse button to obtain the dropdown menu.                       */
/*                                                                     */
/*                                                                     */
/*                                                                     */
/*                                                                     */
//---------------------------------------------------------------------//
#include <stdlib.h>			// standard definitions
#include <iostream.h>			// C++ I/O
#include <stdio.h>			// C I/O (for sprintf) 
#include <math.h>			// standard definitions

#include <GL/glut.h>			// GLUT
#include <GL/glu.h>			// GLU
#include <GL/gl.h>			// OpenGL

#define FOVY 60
#define NEAR 1               /*clipping plane near and far */
#define FAR 10000
#define NO_LIGHTS 2

FILE *BunnyFile;
GLboolean MYPAUSE = false; //boolean that keep track of pause of game
GLboolean MYTRACE = false;

long NumVer = 0;
long NumTri = 0;
float SCALE = 1;
float TRANSLATEX = 0;
float TRANSLATEY = 0;
float TRANSLATEZ = 0;
float ANGLE = 0;
float ROTATEX = 0;
float ROTATEY = 0;
float ROTATEZ = 0;
float METHOD = 1;
float VIEWERX = 0;
float VIEWERY = 0;
float VIEWERZ = 0;

/* spcular color component for an object */
GLfloat spec_color[4]={1.0, 1.0, 1.0, 1.0};

GLfloat global_ambient_intensity[4] = {0.2, 0.2, 0.2, 1.0};

/* light coordinates */
GLfloat light_coords[NO_LIGHTS][4]={{100,-1.0,1.5,0.0},
						   {-0.5,100,0.5,0.0}};

/* light components */
GLfloat light_ambient[NO_LIGHTS][4]={{0.2, 0.2, 0.2, 1.0},
							{0.2, 0.2, 0.2, 1.0}};


GLfloat light_diffuse[NO_LIGHTS][4]={{1.0, 1.0, 1.0, 1.0},
							{1.0, 1.0, 1.0, 1.0}};


GLfloat light_specular[NO_LIGHTS][4]={{2.0, 2.0, 2.0, 1.0},
							 {2.0, 2.0, 2.0, 1.0}}; 

GLfloat fog_color[]={ 0.5, 0.5, 0.5, 1.0}; /* fog color */

GLfloat bunny_color[4]={1.0, 1.0, 1.0, 1.0};

GLfloat shininess = 100.0;

/* initial viewer location and At location*/
static GLdouble viewer[]= {0.0, 0.0, 0.0}; 
static GLdouble at[]= {0.0, 0.0, 0.0};

/* window dimensi0ns */
int wh=500;
int ww=500;

struct vector
{
	float x;
	float y;
	float z;
};

struct vertex
{
	struct vector ver;
	struct vector normal_ver;
};

struct tvertex
{
	long vertex0;
	long vertex1;
	long vertex2;
	struct vector normal_tri;
};

struct vector p1;
struct vector p2;
struct vector ave_vector;
struct vertex *VectorArray;
struct tvertex *TriangleArray;

void myInit();
void myReshape(int ww, int wh);
void calcTriNormal (long j, long index1, long index2, long index3);
void calcVerNormal(long j, long index1, long index2, long index3);
void myDisplay();
void drawBunny1();
void drawBunny2();
void drawVector(long index1, long index2, long index3);
void drawTriangle(long i, long index1, long index2, long index3);
void myKeyboard(unsigned char c, int x, int y);
void myMenu();
void myMenuEvents(int option);

//-----------------------------------------------------------------------
// main program
//	
//-----------------------------------------------------------------------
int main(int argc, char **argv)
{
					
	glutInit(&argc, argv);   //initialize glut and gl
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(ww, wh);   // window
	//glutInitWindowPosition(0,0);    // upper left
	glutCreateWindow("My OpenGL Program: Assignment 5 - Bunny"); 	// create the window

	//register callbacks
	glutReshapeFunc(myReshape);     // call myReshape if window is resized
	glutDisplayFunc(myDisplay);		//  call myDisplay to redraw window
	//keyboard entries
	glutKeyboardFunc(myKeyboard);   // call myKeyboard when key is hit	

	glEnable(GL_DEPTH_TEST);
	
	myInit();				// our own initializations
	myMenu();				//our menu event
	glutMainLoop();			// pass control to GLUT, start it running
	return 0;               // ANSI C expects this
}

void myInit()
{
	glClearColor(0, 0, 0, 0);		// background color
	glShadeModel(GL_SMOOTH);		// smooth shading
	glEnable(GL_NORMALIZE);
	long i, j;
	char Ver, Tri;



	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);

	glLightfv(GL_LIGHT0, GL_POSITION, light_coords[0]);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient[0]);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse[0]);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular[0]);

	glLightfv(GL_LIGHT1, GL_POSITION, light_coords[1]);
	glLightfv(GL_LIGHT1, GL_AMBIENT, light_ambient[1]);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse[1]);
	glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular[1]);

	viewer[0] = 0;
	viewer[1] = 0;
	viewer[2] = -25;


	if ((BunnyFile = fopen("bunny.txt", "r")) == NULL)
	  exit(0);

	if(fscanf(BunnyFile, "%d\n", &NumVer) == EOF)
	{
		printf("P: There is not data in input file\n");
		exit(0);
	}
	printf("The Number of vectors %d\n", NumVer);
	
	if(fscanf(BunnyFile, "%d\n", &NumTri) == EOF)
	{
		printf("P: There is not data in input file\n");
		exit(0);
	}
	printf("The Number of triangles %d \n", NumTri);

	VectorArray = (struct vertex *)malloc(NumVer * sizeof(struct vertex));
	for (i = 0; i < NumVer; i++)
	{
		if(fscanf(BunnyFile, "%c %f %f %f\n", &Ver, &VectorArray[i].ver.x, &VectorArray[i].ver.y, &VectorArray[i].ver.z) != EOF)
		{
			VectorArray[i].normal_ver.x = 0;
			VectorArray[i].normal_ver.y = 0;
			VectorArray[i].normal_ver.z = 0;
			ave_vector.x += VectorArray[i].ver.x;
			ave_vector.y += VectorArray[i].ver.y;
			ave_vector.z += VectorArray[i].ver.z;
			//printf("The vector array %c %f %f %f\n",Ver, VectorArray[i].ver.x, VectorArray[i].ver.y, VectorArray[i].ver.z);
		}
		else
		{
			printf("P: There is not data in input file\n");
			exit(0);
		}
	}
	
	ave_vector.x = ave_vector.x / NumVer;
	ave_vector.y = ave_vector.y / NumVer;
	ave_vector.z = ave_vector.z / NumVer;
	at[0] = (double) ave_vector.x;
	at[1] = (double) ave_vector.y;
	at[2] = (double) ave_vector.z;

	TriangleArray = (struct tvertex *)malloc(NumTri * sizeof(struct tvertex));

	for (j = 0; j < NumTri; j++)
	{
		
		if(fscanf(BunnyFile, "%c %ld %ld %ld\n", &Tri, &TriangleArray[j].vertex0, &TriangleArray[j].vertex1, &TriangleArray[j].vertex2) != EOF)
		{
			//printf("The triangle array %ld %ld %ld\n", TriangleArray[j].vertex0, TriangleArray[j].vertex1, TriangleArray[j].vertex2);
			//printf("i am in front of triangle norlal\n");
			calcTriNormal(j, TriangleArray[j].vertex0, TriangleArray[j].vertex1, TriangleArray[j].vertex2);
			calcVerNormal(j, TriangleArray[j].vertex0, TriangleArray[j].vertex1, TriangleArray[j].vertex2);
		}
		else
		{
			printf("P: There is not data in input file\n");
			exit(0);
		}
	}		
}

void myReshape(int ww, int wh) 
{
	
   // update projection
  glViewport (0, 0, ww,  wh);  // update the viewport
/* Use a perspective view */
  glMatrixMode(GL_PROJECTION);              // update the projection
  glLoadIdentity();               
  gluPerspective(FOVY,(GLdouble) ww/wh, NEAR, FAR);
  glMatrixMode(GL_MODELVIEW);

  glutPostRedisplay();                      // request redisplay
}

//-----------------------------------------------------------------------
// Normalise program
//	
//-----------------------------------------------------------------------
void calcTriNormal (long j, long index1, long index2, long index3)
{
	struct vector v1;
	struct vector v2;

	struct vector v3;

	// Finds The Vector Between 2 Points By Subtracting
	// The x,y,z Coordinates From One Point To Another.
	v1.x = VectorArray[index1].ver.x;
	v1.y = VectorArray[index1].ver.y;
	v1.z = VectorArray[index1].ver.z;
	
	v2.x = VectorArray[index2].ver.x;
	v2.y = VectorArray[index2].ver.y;
	v2.z = VectorArray[index2].ver.z;

	v3.x = VectorArray[index3].ver.x;
	v3.y = VectorArray[index3].ver.y;
	v3.z = VectorArray[index3].ver.z;

	// Calculate The Vector From Point 1 To Point 0
	p1.x = v1.x - v2.x;					// Vector 1.x=Vertex[0].x-Vertex[1].x
	p1.y = v1.y - v2.y;					// Vector 1.y=Vertex[0].y-Vertex[1].y
	p1.z = v1.z - v2.z;					// Vector 1.z=Vertex[0].y-Vertex[1].z
	// Calculate The Vector From Point 2 To Point 1
	p2.x = v2.x - v3.x;					// Vector 2.x=Vertex[0].x-Vertex[1].x
	p2.y = v2.y - v3.y;					// Vector 2.y=Vertex[0].y-Vertex[1].y
	p2.z = v2.z - v3.z;					// Vector 2.z=Vertex[0].z-Vertex[1].z
	// Compute The Cross Product To Give Us A Surface Normal
	TriangleArray[j].normal_tri.x = (p1.y*p2.z) - (p1.z*p2.y);				// Cross Product For Y - Z
	TriangleArray[j].normal_tri.y = (p1.z*p2.x) - (p1.x*p2.z);				// Cross Product For X - Z
	TriangleArray[j].normal_tri.z = (p1.x*p2.y) - (p1.y*p2.x);				// Cross Product For X - Y
}

void calcVerNormal(long j, long index1, long index2, long index3)
{
	//compute vertex normals  by adding traignle normals to vertex normals
	VectorArray[index1].normal_ver.x = VectorArray[index1].normal_ver.x + TriangleArray[j].normal_tri.x;
	VectorArray[index2].normal_ver.y = VectorArray[index2].normal_ver.y + TriangleArray[j].normal_tri.y;
	VectorArray[index3].normal_ver.z = VectorArray[index3].normal_ver.z + TriangleArray[j].normal_tri.z;
}


//-----------------------------------------------------------------------
// Display program
//	
//-----------------------------------------------------------------------
void myDisplay()
{
	//glClearColor(1.0,1.0,1.0,0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);       // clear the window
	glMatrixMode(GL_MODELVIEW);

	/* Update viewer position in modelview matrix */
	glLoadIdentity();
	gluLookAt(viewer[0] + VIEWERX, viewer[1] + VIEWERY, viewer[2] + VIEWERZ, at[0], at[1], at[2], 0.0, 1.0, 0.0);

	if (METHOD == 1)
	{
		glScalef(SCALE, SCALE, SCALE);
		glTranslated(TRANSLATEX, TRANSLATEY, TRANSLATEZ);
		glRotatef(ANGLE, ROTATEX, ROTATEY, ROTATEZ);
		drawBunny1();
	}
	else if (METHOD == 2)
	{
		glScalef(SCALE, SCALE, SCALE);
		glTranslated(TRANSLATEX, TRANSLATEY, TRANSLATEZ);
		glRotatef(ANGLE, ROTATEX, ROTATEY, ROTATEZ);
		drawBunny2();
	}
	else 
	{
		printf("ERROR: Displaying Bunny");
	}

	glutSwapBuffers();		// swap buffers			
	glFlush();				// force OpenGL to render now		
}

void drawVector(long index1, long index2, long index3)
{
	glBegin(GL_POLYGON);
			
		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, bunny_color);
		glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, bunny_color);
		glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, bunny_color);
		glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, shininess);

		glNormal3f(VectorArray[index1].normal_ver.x, VectorArray[index1].normal_ver.y, VectorArray[index1].normal_ver.z);
		glVertex3f(VectorArray[index1].ver.x, VectorArray[index1].ver.y, VectorArray[index1].ver.z);

		glNormal3f(VectorArray[index2].normal_ver.x, VectorArray[index2].normal_ver.y, VectorArray[index2].normal_ver.z);
		glVertex3f(VectorArray[index2].ver.x, VectorArray[index2].ver.y, VectorArray[index2].ver.z);
			
		glNormal3f(VectorArray[index3].normal_ver.x, VectorArray[index3].normal_ver.y, VectorArray[index3].normal_ver.z);
		glVertex3f(VectorArray[index3].ver.x, VectorArray[index3].ver.y, VectorArray[index3].ver.z);

	glEnd();
}

void drawTriangle(long j, long index1, long index2, long index3)
{

	glBegin(GL_POLYGON);
		
		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, bunny_color);
		glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, bunny_color);
		glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, bunny_color);
		glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, shininess);

		glNormal3f(TriangleArray[j].normal_tri.x, TriangleArray[j].normal_tri.y, TriangleArray[j].normal_tri.z );
		glVertex3f(VectorArray[index1].ver.x, VectorArray[index1].ver.y, VectorArray[index1].ver.z);

		glNormal3f(TriangleArray[j].normal_tri.x, TriangleArray[j].normal_tri.y, TriangleArray[j].normal_tri.z);
		glVertex3f(VectorArray[index2].ver.x, VectorArray[index2].ver.y, VectorArray[index2].ver.z);
	
		glNormal3f(TriangleArray[j].normal_tri.x, TriangleArray[j].normal_tri.y, TriangleArray[j].normal_tri.z);
		glVertex3f(VectorArray[index3].ver.x, VectorArray[index3].ver.y, VectorArray[index3].ver.z);
	glEnd();
}

void drawBunny1()
{
	long j = 0;

	for (j = 0; j < NumTri; j++)
	{
		drawTriangle(j, TriangleArray[j].vertex0, TriangleArray[j].vertex1, TriangleArray[j].vertex2);
	}

}

void drawBunny2()
{
	long i = 0;

	for (i = 0; i < NumVer; i++)
	{
		drawVector(TriangleArray[i].vertex0, TriangleArray[i].vertex1, TriangleArray[i].vertex2);
	}
}
//-----------------------------------------------------------------------
// Keyboard program
//	
//-----------------------------------------------------------------------
void myKeyboard(unsigned char c, int x, int y)
{
	switch (c)
	{
	  case 'q':
		  exit(0);			// exit
		  break;
	
	}
	glutPostRedisplay();		// request redisplay
}
//-----------------------------------------------------------------------
// Menu program
//	
//-----------------------------------------------------------------------
void myMenu()
{
	int menu, scaleMenu, translateMenu, rotateMenu, shadingMenu, viewerMenu;

	scaleMenu = glutCreateMenu(myMenuEvents);
	glutAddMenuEntry("Double", 1);
	glutAddMenuEntry("Half", 2);
	glutAddMenuEntry("20%", 3);

	translateMenu = glutCreateMenu(myMenuEvents);
	glutAddMenuEntry("+X", 4);
	glutAddMenuEntry("-X", 5);
	glutAddMenuEntry("+Y", 6);
	glutAddMenuEntry("-Y", 7);
	glutAddMenuEntry("+Z", 8);
	glutAddMenuEntry("-Z", 9);

	rotateMenu = glutCreateMenu(myMenuEvents);
	glutAddMenuEntry("+X", 10);
	glutAddMenuEntry("-X", 11);
	glutAddMenuEntry("+Y", 12);
	glutAddMenuEntry("-Y", 13);
	glutAddMenuEntry("+Z", 14);
	glutAddMenuEntry("-Z", 15);	

	shadingMenu = glutCreateMenu(myMenuEvents);
	glutAddMenuEntry("Method 1", 16);
	glutAddMenuEntry("Method 2", 17);

	viewerMenu = glutCreateMenu(myMenuEvents);
	glutAddMenuEntry("+X", 18);
	glutAddMenuEntry("-X", 19);
	glutAddMenuEntry("+Y", 20);
	glutAddMenuEntry("-Y", 21);
	glutAddMenuEntry("+Z", 22);
	glutAddMenuEntry("-Z", 23);	

	menu = glutCreateMenu(myMenuEvents);
	glutAddSubMenu("Scale Options", scaleMenu);
	glutAddSubMenu("Translate Options", translateMenu);
	glutAddSubMenu("Rotate Options", rotateMenu);
	glutAddSubMenu("Switch Shading Option", shadingMenu);
	glutAddSubMenu("Viewer Option", viewerMenu);

	glutAttachMenu(GLUT_RIGHT_BUTTON);

}

void myMenuEvents(int option) 
{
	switch (option) {
		case 1:  
			printf("Double Scale\n"); 
			SCALE += 2;
			break;
		case 2:	  printf("Half Scale\n"); 
			SCALE -= 2;
			break;
		case 3:  printf("Twenty % scale\n");
			SCALE -= .2;
			break;
		case 4:    printf("Positive X trans\n");
			TRANSLATEX += 1;
			break;
		case 5:	  printf("Negative X trans");
			TRANSLATEX -= 1;
			break;
		case 6:    printf("Pos Y trans\n");
			TRANSLATEY += 1;
			break;
		case 7:	  printf("Neg Y trans\n");
			TRANSLATEY -= 1;
			break;
		case 8:    printf("Pos Z trans\n");
			TRANSLATEZ += 1;
			break;
		case 9:	  printf("Neg Z trans\n");
			TRANSLATEZ -= 1;
			break;
		case 10:   printf("Post X Rot\n");
			ANGLE += 30;
			ROTATEX += 1;
			break;
		case 11:	  printf("Neg X rot\n");
			ANGLE -= 30;
			ROTATEX -= 1;
			break;
		case 12:   printf("Pos Y Rot\n");
			ANGLE += 30;
			ROTATEY += 1;
			break;
		case 13:   printf("Neg Y rot\n");
			ANGLE -= 30;
			ROTATEY -= 1;
			break;
		case 14:   printf("Pos Z rot\n");
			ANGLE += 30;
			ROTATEZ += 1;
			break;
		case 15:   printf("Neg Z rot\n");
			ANGLE -= 30;
			ROTATEZ -= 1;
			break;
		case 16:   printf("drawBunny1\n");
			METHOD = 1;
			break;
		case 17:   printf("drawBunny2\n");
			METHOD = 2;
			break;
		case 18:    printf("Positive X view\n");
			VIEWERX += 5;
			break;
		case 19:	  printf("Negative X view");
			VIEWERX -= 5;
			break;
		case 20:    printf("Pos Y view\n");
			VIEWERY += 5;
			break;
		case 21:	  printf("Neg Y view\n");
			VIEWERY -= 5;
			break;
		case 22:    printf("Pos Z view\n");
			VIEWERZ += 5;
			break;
		case 23:	  printf("Neg Z view\n"); 
			VIEWERZ -= 5;
			break;
	}
	glutPostRedisplay();		// request redisplay
}

                    </pre>
				  </div>
				</div>
				<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Videos/ComputerGraphics_Bunny.flv" title="Random Search">See Video</a></h4>
			</p>
        </div>
		<div class="article">
          <h2><span>Shaders</span></h2>
          <div class="clr"></div>
			<p>
			<div class="panelcollapsed">
			  <h3>Argyle Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: c;" style="overflow: hidden;">
class argyle(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.1, Km = 0.05;
				color red = color (1, 0, 0), blue = color(0,0,1), yellow = color(1,1,0), orange = color(1,0.25,0);
				float sRepeat = 6,tRepeat = 3, fuzz = 0.01;
)
{
	varying color Ct = 0;
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		float ss = mod(s * sRepeat,1);
		float tt = mod(t * tRepeat,1);
	
		//creating an orange diamond in the middle of the plane
		float orangeDiamond1 = smoothstep(-0.45-fuzz,-0.45+fuzz,ss-tt) - smoothstep(0.45-fuzz,0.45+fuzz,ss-tt);
		float orangeDiamond2 = smoothstep(0.55-fuzz,0.55+fuzz,ss+tt) - smoothstep(1.45-fuzz,1.45+fuzz,ss+tt);
		float orangeClamp = clamp((orangeDiamond1*orangeDiamond2),0,1);
		Ct = mix(red,orange,orangeClamp);

		//creatings a yellow X on the plane and the ss and tt are simply repeating the pattern
				float yellowCross1 = smoothstep(-0.08-fuzz,-0.08+fuzz,ss-tt) - smoothstep(0.08-fuzz,0.08+fuzz,ss-tt);                
		float yellowCross2 = smoothstep(0.92-fuzz,0.92+fuzz,ss+tt) - smoothstep(1.08-fuzz,1.08+fuzz,ss+tt);
				//this is just clamping the yellow x together so that it does not affect the intersection
				float yellowClamp = clamp(yellowCross1+yellowCross2,0,1);
				//mixing the colors
				 Ct = mix(Ct,yellow,yellowClamp);

		float diff = (orangeClamp * yellowClamp);
		Ct = mix(Ct, blue,diff);

				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * diff * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;

		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Argyle.jpg" title="Argyle Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Back Board Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 /*
	Author: Hardik Bhatt
  
	PARAMETERS:
	Ks			- coefficient of specular
	Kd			- coefficient of diffuse
	Ka			- coefficient of ambient
	Kr			- coefficient of reflectivity
	Km			- 
	roughness		- 
	colors		-
	repeat		- 
	fuzz		-
	outerBox1		-
	outerBox2		-
	innerBoxS1		-
	innerBoxS2		-
	innerBoxT1		-
	innerBoxT2		-
	dist		-
*/
class BackBoardshader (float Ka = 0.5, Kd = 0.5, Ks = 0.1, Km = 0.05, roughness = 0.01;
			color specularcolor = color(1,1,1), black = (0,0,0), blue = (0,0,1);
			float repeat = 5, fuzz = 0.01, refractIndex = 1.33, transp = .5;
			float outerBox1 = 0.05, outerBoxs2 = 0.95, innerBoxS1 = 0.2, innerBoxS2 = 0.6, innerBoxT1 = 0.3, innerBoxT2 = 0.7, dist = 0.05;
)
{
	varying color Ct = 0;
	
	float inOuterBox()
	{
		float OutBox1 = smoothstep(outerBox1-fuzz,outerBox1+fuzz,s) - smoothstep(outerBoxs2-fuzz,outerBoxs2+fuzz,s);
		float OutBox2 = smoothstep(outerBox1-fuzz,outerBox1+fuzz,t) - smoothstep(outerBoxs2-fuzz, outerBoxs2+fuzz,t);
		float boxOut = OutBox1 * OutBox2;
		float outerBox = clamp(boxOut,0,1);
		
		return outerBox;
	}

	float inInnerBox()
	{
		
		float InblueBox1 = smoothstep(innerBoxS1-fuzz, innerBoxS1+fuzz,s) - smoothstep(innerBoxS2-fuzz,innerBoxS2+fuzz,s);
		float InblueBox2 = smoothstep(innerBoxT1-fuzz,innerBoxT1+fuzz,t) - smoothstep(innerBoxT2-fuzz,innerBoxT2+fuzz,t);
		float InwhiteBox1 = smoothstep((innerBoxS1 + dist)-fuzz,(innerBoxS1 + dist)+fuzz,s) - smoothstep((innerBoxS2-dist)-fuzz,(innerBoxS2-dist)+fuzz,s);
		float InwhiteBox2 = smoothstep((innerBoxT1+dist)-fuzz,(innerBoxT1+dist)+fuzz,t) - smoothstep((innerBoxT2-dist)-fuzz,(innerBoxT2-dist)+fuzz,t);

		float blueBoxIn = InblueBox1 * InblueBox2;
		float whiteBoxIn = InwhiteBox1 * InwhiteBox2;
		float innerBox = clamp(blueBoxIn-whiteBoxIn,0,1);

		return innerBox;
	}

	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		
		P += Km * Ng;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nn = normalize(N);
		vector In =  normalize(I);
		normal Nf = faceforward(Nn, In);
		color reflCol = 0;
	
		if (Nn.-In >= 0)
		{

			vector reflDir = refract(Nn,In, refractIndex);
			reflCol = trace(P,reflDir);
		}


		float outerBox = inOuterBox();
		Ct = mix(specularcolor,reflCol,outerBox);
		
		float innerBox = inInnerBox();
		Ct = mix(Ct, specularcolor, innerBox);	

		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nn, In, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os - transp;
		Ci = Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_BBallBasket.jpg" title="Back Board Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Bench Plank Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
/*
 *  Author: Hardik Bhatt
 *
 *  PARAMETERS:
 *  Ks			- coefficient of specular
 *  Kd			- coefficient of diffuse
 *  Ka			- coefficient of ambient
 *  Kr			- coefficient of reflectivity
 *  Km			- 
 *  roughness		- 
 *  colors		-
 *  repeat		- 
 *  fuzz		-
 *  
*/

class Plankshader (	float Ka = 0.5, Kd = 0.5, Ks = 0.2, Km = 0.05, roughness = 0.01;
			color Clightwood = color(.5,.2,.067), Cdarkwood = color(0.15,0.077,0.028), Cgroove = color(0.02, 0.02, 0.02);
			float repeat = 2, fuzz = 0.01, swirl = .25, swirlFreq = 2, ringDensity = 2, noiFreq = 4, sRepeat = 5;
			float stripeFuzz = .5, turbFreq = 50;
			string space = "shader";
)
{
	varying color Ct = 0;

	float inLineTurb()
	{
		point PP = transform(space,P);
		float i;
		float turbMult = 1;
		float turb = smoothstep((stripeFuzz*2)-fuzz,(stripeFuzz*2)+fuzz,s)*swirl*noise(swirlFreq*PP);
		for(i = 0; i %3c turbFreq; i +=1)
		{
			turb += smoothstep((stripeFuzz/turbMult)-fuzz,(stripeFuzz/turbMult)+fuzz,s)*swirl*noise(swirlFreq*PP);
			turbMult += 2;
		}
		return turb;
	}

	float inCenterRing()
	{
		point center = (sRepeat,0,0);
		point here = point(s*(sRepeat*2),t,0);
		float dist = distance(center,here)+inLineTurb();
		float alpha = mod(ringDensity*dist,1);
		float inCircle = (floor((alpha)*repeat));
		float ring = clamp(mod(inCircle,1.2),0,1);

		return ring;

	}
	float inCenterStripe()
	{
		float sCenter = s-.5;
			float tCenter = t-1;
			float theta = atan(tCenter,sCenter) * (PI/2);
			float indStripe = floor(theta*repeat);
			float polarStripe = mod(indStripe,2);
	
		return polarStripe;
	}

	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);


		P += Km * Ng;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);
		
		float ring = inCenterRing();
		Ct = spline(ring, Clightwood,Clightwood,Cdarkwood,Cgroove,Clightwood,Cgroove,Cdarkwood,Clightwood);

		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="" title="Bench Plank Shader">See Image</a></h4><br />
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Block Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
class block_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color blue = color (0, 0, 0.5), orange = color(1,0.75,0);
				float width = 0.2, stripeS = 0.25;)
{
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		//multiplying the s stripe and the t stripe to get the box in the middle
				float blueStripe = (step(0.2,s) - step(0.5,s)) * (step(0.2,t) - step(.5,t));
		float blueClamp = clamp(blueStripe,0,1);
				
		color Ct = mix(orange,blue,blueClamp);


				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Block.jpg" title="Block Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Bullseye Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class bullseye_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color white = color (1, 1, 1), red = color (1, 0, 0), gray = color(0,0,1);//declaring the color mix
				float width = 0.2, stripeS = 0.1, repeat = 5, fuzz = 0.01;
		output varying color _ambient = 0, _diffuse = 0, _specular = 0;)
{
	varying color Ct = 0;
	public void surface(output color Ci, Oi)
	{

		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);
		//declaring the center of the object
		point center = (0.5,0.5,0);
		//declaring the entire object
		point here = (s,t,0);
		float dist = distance (center,here);
		
		float inCircle = smoothstep(0.48-fuzz,0.48+fuzz,dist);
		Ct = mix(white,gray,inCircle);
		
		float inCircle2 = smoothstep(0.40-fuzz,0.40+fuzz,dist);
		Ct = mix(red,Ct,inCircle2);
		
		float inCircle3 = smoothstep(0.32-fuzz,0.32+fuzz,dist);
		Ct = mix(white,Ct,inCircle3);
		
		float inCircle4 = smoothstep(0.24-fuzz,0.24+fuzz,dist);
		Ct = mix(red,Ct,inCircle4);
	
		float inCircle5 = smoothstep(0.16-fuzz,0.16+fuzz,dist);
		Ct = mix(white,Ct,inCircle5);

		float inCircle6 = smoothstep(0.08-fuzz,0.08+fuzz,dist);
		Ct = mix(red, Ct,inCircle6);
	
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd *  Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;
 
		Oi = Os;
		Ci = Oi * Ct;
		
		_ambient = cAmb;
		_diffuse = cDiff;
		_specular = cSpec;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Bullseye.jpg" title="Bullseye Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Bumpy Circle Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class bumpyCircle_test(
	float Ka = 0.5, Kd = 0.5, Ks = 1, Km = 0.03, roughness = 0.1;
	color white = color (1,1,1), blue = color(0,0,1), specularcolor = 1;
	float radius = .5, fuzz = 0.05, repeat = 10, amp = .5;)
{
	varying float inCircle;
	varying color Ct;
	varying color randColor;
	public void displacement(output point P; output normal N)
	{
		normal Ng = normalize(N);
		
		float tRepeat = 2 * repeat;
		float ss = mod(s*repeat,1);
		float tt = mod(t*repeat,1);
		
		float sRow = floor(s*repeat);
		float tRow = floor(t*repeat);

		if(mod(tRow,2) == 0)
		{
			ss = mod(ss+0.5,1);
			sRow = floor(s*repeat+0.5);
		}

		point center = point (0.5+((cellnoise(tRow,sRow)-.5)*.5), 0.5+((cellnoise(tRow,sRow)-.5)*.5), 0);
		point here = point (ss,tt,0);

		float randRad = clamp((cellnoise(tRow, sRow)+.3)*.3,.15,.25);
		randColor = blue*cellnoise(tRow,sRow);
		
		float dist = distance(center,here);

		inCircle = smoothstep((randRad-fuzz),(randRad+fuzz),dist);

		P += Km * Ng * inCircle;
		N = calculatenormal(P);

	}

	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N,I));
		vector V = -normalize(I);
		
		Ct = mix(randColor, white, inCircle);

		color cAmb = Ct * Ka * ambient();
		color cDiff = Ct * Kd * diffuse(Nf);
		color cSpec = specularcolor * Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Ct * Oi;

	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_BumpyCircles.jpg" title="Bumpy Circle Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Checker Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class checker_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color blue = color (0, 0, 0.5), yellow = color(0.5,0.5,0);//declaring the color mix
				float repeat = 8;)
{
		varying color Ct = 0;
		public void surface(output color Ci, Oi)
		{
				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);

		float row = floor(t*repeat);
		float col = floor(s*repeat);

		float checker =  mod(row+col,2);
		Ct = mix(yellow,blue,checker);
				 

				Oi = Os;
				Ci = Oi * Ct;
		}                        
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Checkers.jpg" title="Checker Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Cross Shader</h3>
			  <div class="panelcontent">
				 <pre class="brush: java;" style="overflow: hidden;">
class cross_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color blue = color (0, 0, 0.5), gray = color(0.75,0.75,0.75);
				float width = 0.2, stripeS = 0.25;)
{
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		//s-t and s+t are crossing
				float grayCross = (step(-0.15,s-t) - step(0.15,s-t)) + (step(0.85,s+t) - step(1.15,s+t));
		//clamping the crossing lines
		float grayClamp = clamp(grayCross,0,1);
				//mixing the gray crosses and blue background together.
		color Ct = mix(blue,gray,grayClamp);


				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="" title="Cross Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Layers Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class layers_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color blue = color (0, 0, 0.5), orange = color(1,0.75,0);
				float width = 0.2, stripeS = 0.25;)
{
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);

				float blueStripe = (step(0.2,s) - step(0.5,s)) + (step(0.2,t) - step(.5,t));
		float blueClamp = clamp(blueStripe, 0, 1);
				
		color Ct = mix(orange,blue,blueClamp);


				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Layers.jpg" title="Layers Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Basket Ball Net Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class NetShader(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.01;
				color blue = color (0, 0, 0.5), red = color(0.5,0,0), white = color(1,1,1), darkred = color(.25,0,0), 
				gray = color(.25,.25,.25); float repeat = 50, fuzz = 0.01; )
{
	varying color Ct;
	float inStripes()
	{
		float inStripe = 0;
		float ss = mod(s*repeat,1);
		float tt = mod(t*repeat,1);

		float sRow = floor(s*repeat);
		float tRow = floor(t*repeat);

		if((mod(sRow,2) == 0 && mod(tRow,2) == 1) || (mod(tRow,2) == 0 && mod(sRow,2) == 1))
		{
			//creating gray stripe down
						float grayStripe = smoothstep(0.45-fuzz,0.45+fuzz,ss) - smoothstep(0.55-fuzz,0.55+fuzz,ss);
						inStripe = grayStripe;

						//creating a blue stripe across
						float blueStripe = smoothstep(0.4-fuzz,0.4+fuzz,tt) - smoothstep(0.6-fuzz,0.6+fuzz,tt);
						inStripe = blueStripe;

		}
		else
		{
						//creating a blue stripe across
						float blueStripe = smoothstep(0.4-fuzz,0.4+fuzz,tt) - smoothstep(0.6-fuzz,0.6+fuzz,tt);
						inStripe = blueStripe;
			
			//creating gray stripe down
						float grayStripe = smoothstep(0.45-fuzz,0.45+fuzz,ss) - smoothstep(0.55-fuzz,0.55+fuzz,ss);
						inStripe = grayStripe;
		}

		return inStripe;

	}
		public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		
		float patt = inStripes();
		
		P += Km * Ng * -patt;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nn = normalize(N);
		vector In =  normalize(I);
		normal Nf = faceforward(Nn, In);
		
		float patt = inStripes();
		Ct = mix(gray,white,patt);
	
	
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nn, In, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/ShaderCam5.jpg" title="Net Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Over Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class over_test(
				float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
				color blue = color (0, 0, 1), red = color (1, 0, 0), greed = color(0,1,0), yellow = color(1,1,0), 
				gray = color(0.75,0.75,0.75), orange = color(1,0.75,0); float width = 0.2, stripeS = 0.25;)
{
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		//creating the blue box with a gray background
				float blueBox = (step(0.80,s) - step(1,s)) + (step(0.80,t) - step(1,t));
		//clamping the blue box with the gray background
		float blueClamp = clamp(blueBox, 0, 1);
				//mixing the blue and gray colors together
		color Ct = mix(blue,gray,blueClamp);

		//creatung the red box 
		float redBox = (step(0.60,s) - step(0.80,s)) + (step(0.60,t) - step(0.80,t));
		//clamping the red box with the blue clamped box
		float redClamp = clamp(redBox+blueClamp, 0, 1);
		//mixing in the red color with and Ct background
		Ct = mix(red,Ct,redClamp);
		
		//creating the yellow box
		float yellowBox = (step(0.40,s) - step(0.60,s)) + (step(0.40,t) - step(0.60,t));
		//clamping the yellow box with the red clamped box
		float yellowClamp = clamp(yellowBox+redClamp,0,1);
		//mixing in the yellow color with and Ct background
		Ct = mix(yellow,Ct,yellowClamp);

		//creating an orange box
		float orangeBox = (step(0.20,s) - step(0.40,s)) + (step(0.20,t) - step(0.40,t));
		//clamping the orange box with the yellow clamped box
		float orangeClamp = clamp(orangeBox+yellowClamp,0,1);
		//mixing the orange color with and Ct background
		Ct = mix(orange,Ct,orangeClamp);

				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;
				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Over.jpg" title="Over Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Pavement Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
/*
 *  Author: Hardik Bhatt
 *
 *  PARAMETERS:
 *  Ks			- coefficient of specular
 *  Kd			- coefficient of diffuse
 *  Ka			- coefficient of ambient
 *  Kr			- coefficient of reflectivity
 *  Km			- 
 *  roughness		- 
 *  colors		-
 *  repeat		- 
 *  fuzz		-
 *  
*/
class Pavementshader (	float Ka = 0.5, Kd = 0.5, Ks = 1.0, Km = 0.03, roughness = 0.01;
		color white = color(1,1,1), black = color(0,0,0), yellow = color(1,1,0), orange = color(0,1,1);
		float repeat = 5, fuzz = 0.01, noiFreq = 10, octaves = 3;
		string maskFile = "BasketballCourt.tx";
)
{
	varying color Ct = 0;

	float paveNoise()
	{
		float noi = noise(transform("shader",P*noiFreq));
		
		return noi;
	}

	float paveTurb()
	{
		float turb = 0, i;
		point PP = transform("shader", P);
		for(i=0;i %3c octaves; i+=1)
		{
			float snoise = noise(PP*500)*2-1;
			turb += abs(snoise*i)/i;
		}
		
		return turb;
	}
	
	float inOuterBox()
	{
		float boxOut = (smoothstep(0.1-fuzz,0.1+fuzz,s) - smoothstep(0.9-fuzz,0.9+fuzz,s)) * (smoothstep(0.1-fuzz,0.1+fuzz,t) - smoothstep(0.9-fuzz, 0.9+fuzz,t));
		float outerBox = clamp(boxOut,0,1);
		
		return outerBox;
	}

	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);

		float noi = paveNoise();
		float turb = paveTurb();

		P += Km * Ng * noi * turb;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);
		
		float ps_mask = texture(maskFile);
				Ct = mix(black, white, ps_mask);
		
		float noi = paveNoise(); 
		float turb = paveTurb();
		Ct = mix(black, Ct,turb+noi);
	
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Pavement.jpg" title="Pavement Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Plaid Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
class plaid_test(
	float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
	color blue = color (0, 0, 0.5), red = color(0.5,0,0), white = color(1,1,1), darkred = color(.25,0,0), 
	gray = color(.25,.25,.25); float repeat = 6, fuzz = 0.01;)
{
	varying color Ct;
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		float ss = mod(s*repeat,1);
		float tt = mod(t*repeat,1);

		float sRow = floor(s*repeat);
		float tRow = floor(t*repeat);

		//creating red stripe 1 across
				float redStripe1 = smoothstep(0.3-fuzz,0.3+fuzz,tt) - smoothstep(0.7-fuzz,0.7+fuzz,tt);

		//creating red stripe 2 down
		float redStripe2 = smoothstep(0.3-fuzz,0.3+fuzz,ss) - smoothstep(0.7-fuzz,0.7+fuzz,ss);
		Ct = mix(white,red,redStripe1+redStripe2);
	
		if((mod(sRow,2) == 0 && mod(tRow,2) == 1) || (mod(tRow,2) == 0 && mod(sRow,2) == 1))
		{
			//creating gray stripe down
						float grayStripe = smoothstep(0.45-fuzz,0.45+fuzz,ss) - smoothstep(0.55-fuzz,0.55+fuzz,ss);
						Ct = mix(Ct,gray,grayStripe);

						//creating a blue stripe across
						float blueStripe = smoothstep(0.4-fuzz,0.4+fuzz,tt) - smoothstep(0.6-fuzz,0.6+fuzz,tt);
						Ct = mix(Ct,blue,blueStripe);

		}
		else
		{
						//creating a blue stripe across
						float blueStripe = smoothstep(0.4-fuzz,0.4+fuzz,tt) - smoothstep(0.6-fuzz,0.6+fuzz,tt);
						Ct = mix(Ct,blue,blueStripe);
			
			//creating gray stripe down
						float grayStripe = smoothstep(0.45-fuzz,0.45+fuzz,ss) - smoothstep(0.55-fuzz,0.55+fuzz,ss);
						Ct = mix(Ct,gray,grayStripe);

		}
				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Plaid.jpg" title="Plaid Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Ramp Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
class ramp_test(
			float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
			color blue = color (0, 0, 0.5), yellow = color(0.5,0.5,0);)//declaring the color mix
{
	varying color Ct = 0;
	public void surface(output color Ci, Oi)
	{
			normal Nf = normalize(faceforward(N, I));
			vector V = -normalize(I);

			color Ct = mix(yellow,blue,s);

			Oi = Os;
			Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Ramp.jpg" title="Ramp Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Random Circles Shader</h3>
			  <div class="panelcontent">
				 <pre class="brush: java;" style="overflow: hidden;">
 class randCircles_test(
			float Ka = 0.5, Kd =0.5, Ks = 1, Km = 0.5, roughness = 0.1;
			color yellow = color(0.25,0.25,0), blue = color(0,0,0.25);
			float repeat = 8, fuzz = 0.01;
)
{
	varying float randColor = 0;
	float inRandColor()
	{	
		float ss = mod(s*repeat,1);
		float tt = mod(t*repeat,1);

		float row = floor(t*repeat);
		float col = floor(s*repeat);

		point center = point(0.5,0.5,0);
		point here = point(ss,tt,0);
		float rand = cellnoise(row, col) * 0.5;
		float dist = distance(center,here);

		float inRandColor = smoothstep(0-fuzz,0+fuzz,rand - dist);
		return inRandColor;
	}
	public void displacement(output point P; output normal N)
	{
		randColor = inRandColor();
	}
	public void surface(output color Ci, Oi)
	{
		Ci = mix(blue, yellow, randColor);
	}
}
                    </pre>
			  </div>
			</div>
			 <h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_RandomCircles.jpg" title="Random Circles Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Ridges Shader</h3>
			  <div class="panelcontent">
				 <pre class="brush: java;" style="overflow: hidden;">
class ridges_test(
	float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
	color red = color (1, 0, 0), blue = color(0,0,1);
	float stripeS = 0.1, amp = 6, fuzzS = 0.1, fuzzT = 0.25;
)
{
	varying color Ct = 0;
	varying float hump = 0.0;
	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		float ss = mod(s*amp,1);
		
		hump = (smoothstep(0.25 - fuzzS, 0.25 + fuzzS,ss) - smoothstep(0.75 - fuzzS, 0.75 + fuzzS,ss)) * (smoothstep(0.8 -fuzzT, 0.8 +fuzzT,t) - smoothstep(0.2 - fuzzT, 0.2 + fuzzT,t)) ;

		P += hump * Km * Ng;
		N = calculatenormal(P);
	}
	public void surface(output color Ci, Oi)
	{

		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);
	
		Ct = mix(red,red,hump);

		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd *  Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;
 
		Oi = Os;
		Ci = Oi * Ct;
		
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Ridges.jpg" title="Ridges Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Rings Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class rings_test(
	float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
	color blue = color (0, 0, 0.5), yellow = color(0.5,0.5,0);//declaring the color mix
	float repeat = 8;
)
{
		varying color Ct = 0;
		varying float rings = 0;
	varying vector randCell = 0;
	float inRings()
	{
		point center = point(0.5, 0.5, 0);
		point here = point (s,t,0);
		float dist = distance(center,here);
		float flrCircle = floor(dist*repeat*2);
		float inRings = mod(flrCircle,2);
		
		return inRings;

	}
	public void displacement(output point P; output normal N)
	{
		rings = inRings();
	}
	public void surface(output color Ci, Oi)
		{
		normal Nn = normalize(N);
		normal Nf = faceforward(Nn,I);
		vector V = -normalize(I);

		Ct = mix(yellow, blue, rings);

		Oi = Os;
		Ci = Ct * Oi;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Rings.jpg" title="Rings Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Steel Poll Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 /*
	Author: Hardik Bhatt
  
	PARAMETERS:
	Ks			- coefficient of specular
	Kd			- coefficient of diffuse
	Ka			- coefficient of ambient
	Kr			- coefficient of reflectivity
	Km			- 
	roughness		- 
	colors		-
	repeat		- 
	fuzz		-
   
*/
class CourtPollshader (float Ka = 0.5, Kd = 0.5, Ks = 0.1, Km = 0.03, roughness = 0.2;
			color white = color(1,1,1), black = (0,0,0), gray1 = (.25,.25,.25), gray2 = color(.5,.5,.5), gray3 = color(.75,.75,.75);
			float repeat = 5, fuzz = 0.01, noiFreq = 5, octaves = 2, noise = 100;
)
{
	varying color Ct = 0;
	
	float inBumpy()
	{
		float noi = noise(transform("shader", P * noiFreq));

		return noi;
	}

	float inTurb()
	{
		float turb = 0, i;
		point PP = transform("shader", P);
		for(i=0;i%3coctaves; i+=1)
		{
			float snoise = noise(PP*30)*2-1;
			turb += abs(snoise*i)/i;
		}
		
		return turb;
	}
	
	void inVoronoi(point P; float jitter; output float f1, f2; output point pos1, pos2;)
	{
		point currCell = point (floor(P[0])+0.5, floor(P[1])+0.5, floor(P[2])+0.5);

		f1 = f2 = 2000;
		float i, j, k;
		for (i = -1; i%3c=1; i+=1){
			for (j = -1; j%3c=1; j+=1) {
				for (k= -1; k%3c=1; k+=1) {
					point testCell = currCell + vector(i,j,k);
					point pos = testCell + jitter * (vector cellnoise(testCell)-0.5);
					vector offset = pos - P;
					float dist = offset.offset;
					if(dist %3c f1){
						f2 = f1;
						pos2 = pos1;
						f1 = dist;
						pos1 = pos;
					} else if (dist %3c f2) {
						f2 = dist;
						pos2 = pos;
					}
				}
			}
		}
		f1 = sqrt(f1); f2 = sqrt(f2);
	}
	
	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		
		float noi = inBumpy();
		float turb = inTurb();
		
		P += Km * Ng * noi;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);
		
		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;
		
		inVoronoi(P*noise, .9, seedP, shadingP, pos1, pos2);
		Ct = color spline(shadingP - seedP, black, black, white, gray2, white, gray1, gray3);
		
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="" title="Steel Poll Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Stripe Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
 class stripes_test(
	float Ka = 0.5, Kd = 0.5, Ks = 1.0, roughness = 0.01, Km = 0.05;
	color blue = color (0, 0, 1), red = color (1, 0, 0), greed = color(0,1,0), yellow = color(1,1,0), 
	gray = color(0.75,0.75,0.75); float width = 0.2, stripeS = 0.25; )
{
		public void surface(output color Ci, Oi)
		{

				normal Nf = normalize(faceforward(N, I));
				vector V = -normalize(I);
		
		//creating a red stripe on the shader with static parameters
				float redStripe = step(0,s) - step(0.30,s);
		
		//mixing the red stripe with a blue background
				color Ct = mix(blue,red,redStripe);

		//creating a blue stripe on the shader with static parameters
				float blueStripe = step(0.30,s) - step(0.40,s);
		
		//clamping the red stripe and the blue stripe so they do not overlap to another color
				float rednblue = clamp (redStripe+blueStripe,0,1);
		
		//mixing the clamped red and blue stripe with a yellow background
				Ct = mix(yellow,Ct, rednblue);
		
		//creating a yellow stripe on the shader with static parameters
				float yellowStripe = step(0.40,s) - step(0.60,s);
		//clamping the rednblue and yellow stripes together 
				float RBnyellow = clamp(rednblue+yellowStripe,0,1);
		//mixing the rednbluenyellow stripe together with a gray background
				Ct = mix(gray,Ct,RBnyellow);

				color cAmb = Ka * Ct * ambient();
				color cDiff = Kd *  Ct * diffuse(Nf);
				color cSpec = Ks * specular(Nf, V, roughness);

				Ct = cAmb + cDiff + cSpec;

				Oi = Os;
				Ci = Oi * Ct;
		}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Stripes.jpg" title="Stripe Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>TrashCan Shader</h3>
			  <div class="panelcontent">
				 <pre class="brush: java;" style="overflow: hidden;">
/*
 *  Author: Hardik Bhatt
 *
 *  PARAMETERS:
 *  Ks			- coefficient of specular
 *  Kd			- coefficient of diffuse
 *  Ka			- coefficient of ambient
 *  Kr			- coefficient of reflectivity
 *  Km			- 
 *  roughness		- 
 *  colors		-
 *  repeat		- 
 *  fuzz		-
 *  
*/
class TrashCanshader (	float Ka = 0.5, Kd = 0.5, Ks = 1.0, Km = 0.05, roughness = 0.01;
		color white = color(1,1,1), orange = color(0,1,1), black = color(0,0,0), yellow = color(1,1,0);
		float repeat = 5, fuzz = 0.01, octaves = 3, noise = 5;
)
{
	varying color Ct = 0;

	void inVoronoi(point P; float jitter; output float f1, f2; output point pos1, pos2;)
	{
		point currCell = point (floor(P[0])+0.5, floor(P[1])+0.5, floor(P[2])+0.5);

		f1 = f2 = 50;
		float i, j, k;
		for (i = -1; i%3c=1; i+=1){
			for (j = -1; j%3c=1; j+=1) {
				for (k= -1; k%3c=1; k+=1) {
					point testCell = currCell + vector(i,j,k);
					point pos = testCell + jitter * (vector cellnoise(testCell)-0.5);
					vector offset = pos - P;
					float dist = offset.offset;
					if(dist %3c f1){
						f2 = f1;
						pos2 = pos1;
						f1 = dist;
						pos1 = pos;
					} else if (dist %3c f2) {
						f2 = dist;
						pos2 = pos;
					}
				}
			}
		}
		f1 = sqrt(f1); f2 = sqrt(f2);
	}
	
	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);

		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;

				inVoronoi(P*noise, .9, seedP, shadingP, pos1, pos2);

		P += Km * Ng * (.5*seedP);
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);

		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;
		
		inVoronoi(P*noise, .9, seedP, shadingP, pos1, pos2);

		Ct = color spline(shadingP - seedP, black,black, white, orange, white, yellow, orange);
	
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="" title="TrashCanShader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Tree Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
/*
 *  Author: Hardik Bhatt
 *
 *  PARAMETERS:
 *  Ks				- coefficient of specular
 *  Kd				- coefficient of diffuse
 *  Ka				- coefficient of ambient
 *  Kr				- coefficient of reflectivity
 *  Km				- 
 *  roughness			- the roughness parameter of the surface 
 *  colors			-
 *  repeat			- 
 *  fuzz			-
 *  crack_moss_height 		- the hight up to which the moss in the crack should grow
 *  top_moss_height 		- the hight from which the moss should grow on top of the surface
 *  grain 			- the amount of grain to mix the overall color of the surface
 *  baseColor 			- the color for the bottom of the cracks
 *  middleColor 		- the color between the cracks and the top of the surface
 *  topColor			- the color for the top of the surface
 *  topMoss			- the color of the Moss to grow on top of the surface
 *  crackMoss 			- the color of the Moss to grow in the cracks
 *  fBmoctaves 			- the octaves of the Fractional Brownian Motion in order to affect the cracks.
 *  fBmlacunarity 		- the lacunarity of the Fractional Brownian Motion in order to affect the cracks.
 *  fBmgain 			- the gain of the Fractional Brownian Motion in order to affect the cracks.
 *  turboctaves 		- the octaves of the Turbulence in order to add turbulence to the overall texture.
 *  turblcunarity 		- the lacunarity of the Turbulence in order to add turbulence to the overall texture.
 *  turbgain	 		- the gain of the Turbulence in order to add turbulence to the overall texture.
 *  barksmoothness 		- scales the Fractional Motion applied to the cracks
 *  squarness_of_bark_patches 	- will be passed to the jitter of the voronoi function jitter> 1 at your own risk
 *  crack_detail		- the amount of times the voronoi pattern should be applied, increase in high increases your render times 
 *  lowNormaliseRange 		- the min value calculated by the displacement inorder to normalise the output hump.
 *  topNormaliseRange 		- the max value calculated by the displacement inorder to normalise the output hump.
 *  space 			- the space in which the shader should be applied
 *  crack_strech		- stretches the voronoi pattern by this vector
 *  
*/

#include "noises.h"
#include "filterwidth.h"
#include "raysphere.h"

class Treeshader (	float Ka = 1, Kd = 0.7, Ks = 1, Km = 0.1, roughness = 0.5;
			varying color	baseColor = 0, middleColor = 0,	topColor = 0, topMoss = 0,	
					crackMoss = color (0.3,0.3,0.2);
			float repeat = 5, fuzz = 0.01, grain = 0.5, crack_moss_height = 3.0, top_moss_height = 6.0;
			float fBmoctaves=6, fBmlac=2, fBmgain=0.5, turboctaves=4, turblac=2, turbgain=0.5, barksmoothness=0.07; 
			varying float squareness_of_bark_patches=1;
			float crack_detail=5, lowNormaliseRange=0.712768, topNormaliseRange=2.883801; 
			string space="world";
			vector crack_stretch=(0.5,0.25,0.5);
			output varying float hump = 0;
			output varying point cellid = 0;
)
{
	varying color Ct = 0;
	
	void inVoronoi(point P; float jitter; output float f1, f2; output point pos1, pos2;) 
	{
		point currCell = point (floor(P[0])+0.5, floor(P[1])+0.5, floor(P[2])+0.5);

		f1 = f2 = 2000;
		float i, j, k;
		for (i = -1; i%3c=1; i+=1){
			for (j = -1; j%3c=1; j+=1) {
				for (k= -1; k%3c=1; k+=1) {
					point testCell = currCell + vector(i,j,k);
					point pos = testCell + jitter * (vector cellnoise(testCell)-0.5);
					vector offset = pos - P;
					float dist = offset.offset;
					if(dist %3c f1){
						f2 = f1;
						pos2 = pos1;
						f1 = dist;
						pos1 = pos;
					} else if (dist %3c f2) {
						f2 = dist;
						pos2 = pos;
					}
				}
			}
		}
		f1 = sqrt(f1); f2 = sqrt(f2);
	}

	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		point PP = transform("shader",P);
		
		//Transform the vector into the relevant space inorder to stretch the voronoi pattern
		vector cs = vtransform(space,crack_stretch);	

		//stretch the voronoi pattern
		PP = point (comp(cs,0) * comp(PP,0), comp(cs,1) * comp(PP,1), comp(cs,2) * comp(PP,2));
		
		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;
		
		inVoronoi(PP*crack_detail, .9, seedP, shadingP, pos1, pos2);


		P += Km * Ng * (shadingP - seedP);
		N = calculatenormal(P);
	}
	
	
	public void surface(output color Ci, Oi)
	{
		//standard shader initialisation
		normal Nn = normalize(N);
		normal Nf = faceforward(Nn, I);
	
		point PP = transform(space, P);		
		vector V = -normalize(I);
		
		/*generate a variation of colours-*/
		color darkColor = baseColor - 0.025;
		color lowBaseColor =  baseColor + 0.025;
		color lowerMiddleColor = middleColor - 0.0125;
		color higherMiddleColor = middleColor + 0.0125;
		color lowTopColor = topColor - 0.025;
		color higherTopColor = topColor + 0.025;

		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;
		
		inVoronoi(PP, .9, seedP, shadingP, pos1, pos2);

		color finalColor = spline ( shadingP - seedP, darkColor, baseColor, lowBaseColor, 
						lowerMiddleColor, middleColor, higherMiddleColor,
						topColor, lowTopColor,higherTopColor);
		Ct = finalColor;
		
		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_TreeBark.jpg" title="Tree Shader">See Image</a></h4>
			</p>
			<p>
			<div class="panelcollapsed">
			  <h3>Wall Shader</h3>
			  <div class="panelcontent">
				<pre class="brush: java;" style="overflow: hidden;">
/*
	 Author: Hardik Bhatt
   
	PARAMETERS:
	 Ks			- coefficient of specular
	 Kd			- coefficient of diffuse
	 Ka			- coefficient of ambient
	 Kr			- coefficient of reflectivity
	 Km			- 
	 roughness		- 
	 colors		-
	 repeat		- 
	 fuzz		-
   
*/

class Wallshader (	
		float Ka = 0.5, Kd = 0.5, Ks = 0.1, Km = 0.005, roughness = 0.1;
		color white = color(1,1,1), red = color(1,0,0), yellow = color(1,1,0), black = color(0,0,0), orange = color(1,0.8,.5);
		float horizRepeat = 10, fuzz = 0.01, horizMortar = 0.05, octaves = 3;
		 )
{
	varying color Ct = 0;
	varying vector randCell = 0;
	varying float brickNoise = 0;
	
	void inVoronoi(point P; float jitter; output float f1, f2; output point pos1, pos2;)
	{
		point currCell = point (floor(P[0])+0.5, floor(P[1])+0.5, floor(P[2])+0.5);

		f1 = f2 = 2000;
		float i, j, k;
		for (i = -1; i%3c=1; i+=1){
			for (j = -1; j%3c=1; j+=1) {
				for (k= -1; k%3c=1; k+=1) {
					point testCell = currCell + vector(i,j,k);
					point pos = testCell + jitter * (vector cellnoise(testCell)-0.5);
					vector offset = pos - P;
					float dist = offset.offset;
					if(dist %3c f1){
						f2 = f1;
						pos2 = pos1;
						f1 = dist;
						pos1 = pos;
					} else if (dist %3c f2) {
						f2 = dist;
						pos2 = pos;
					}
				}
			}
		}
		f1 = sqrt(f1); f2 = sqrt(f2);
	}
	
	float inTurb()
	{
		float turb = 0, i;
		point PP = transform("shader", P);
		for(i=0;i%3coctaves; i+=1)
		{
			float snoise = noise(PP*500)*2-1;
			turb += abs(snoise*i)/i;
		}
		
		return turb;
	}

	float inBrick()
	{
		float vertRepeat = 0.5*horizRepeat;
		
		float ss = mod(s*horizRepeat,1);
		float tt = mod(t*vertRepeat,1);

		float row = floor(s*horizRepeat);
		float col = floor(t*vertRepeat);

		if(mod(row,2)==0)
		{
			tt=mod(tt+0.5,1);
			col = floor(t*vertRepeat+0.5);
		}
		randCell = cellnoise(row,col);

		float vertMortar = 0.5*horizMortar;

		float sBrick = step(horizMortar,ss)-step(1-horizMortar,ss);
		float tBrick = step(vertMortar,tt)-step(1-vertMortar,tt);

		point PP = transform("shader",P);
		brickNoise = noise(PP*50)*randCell[1]+0.5;
	
		float inBrick = sBrick*tBrick;		
		return inBrick;
	}

	public void displacement (output point P; output normal N)
	{
		normal Ng = normalize(N);
		
		float bricks = inBrick();
		float turb = inTurb();

		P += Km * Ng * -bricks * turb;
		N = calculatenormal(P);
	}
	
	public void surface(output color Ci, Oi)
	{
		normal Nf = normalize(faceforward(N, I));
		vector V = -normalize(I);

		float bricks = inBrick();
		Ct = mix(white,red*randCell[1]*brickNoise, bricks);
		
		varying float seedP = 0, shadingP = 0;
				varying point pos1 = 0, pos2 = 0;
		
		inVoronoi(P*50, .9, seedP, shadingP, pos1, pos2);

		Ct = color spline(shadingP - seedP, black, orange, Ct, white, yellow);

		color cAmb = Ka * Ct * ambient();
		color cDiff = Kd * Ct * diffuse(Nf);
		color cSpec = Ks * specular(Nf, V, roughness);

		Ct = cAmb + cDiff + cSpec;

		Oi = Os;
		Ci = Oi * Ct;
	}
}
                    </pre>
			  </div>
			</div>
			<h4>Output: <a rel="shadowbox;width=600;height=500" href="doc/content/Images/Shader_Brick.jpg" title="Wall Shader">See Image</a></h4>
			</p>
        </div>
      </div>
      <div class="sidebar">
        <div class="clr"></div>
        <div class="gadget">
          <h2 class="star"><span>Sidebar</span> Menu</h2>
          <div class="clr"></div>
          <ul class="sb_menu">
            <li><a href="myResume.html">Resume</a></li>
            <li><a href="gameSamples.html">Game Samples</a></li>
            <li><a href="codeSamples.html">Code Samples</a></li>
            <li><a href="digitalSamples.html">Digital Samples</a></li>
            <li><a href="myHobbies.html">Hobbies</a></li> 
			<li><a href="myTech.html">Resources</a></li>
            <li><a href="myWebsites.html">Favorite Websites</a></li>
          </ul>
        </div>
      </div>
      <div class="clr"></div>
    </div>
  </div>
  <div class="fbg">
    <div class="fbg_resize">
       <div class="col c1">
        <h2><span></span> 	</h2>
        <p></p>    
	  </div>      
      <div class="col c2">
        <h2><span>Contact</span> Me</h2>
        <p>For information regarding my portfolio or even if you just want to say hello.</p>
        <p class="contact_info"> <span>Telephone:</span> +See Resume<br />
		  <span>E-mail:</span><a href="mailto:Hardik.R.Bhatt@gmail.com">Hardik.R.Bhatt@gmail.com</a></p>
      </div>
	  <div class="col c3">
        <h2><span></span> 	</h2>
        <p></p>        
      </div>
      <div class="clr"></div>
    </div>
  </div>
   <div class="footer">
    <div class="footer_resize">
      <p class="lf">&copy; Copyright <a href="http://www.hardibhatt.com/">http://www.hardibhatt.com/</a> 2011.</p>
      <div style="clear:both;"></div>
    </div>
  </div>
</div>
</body>
</html>
