<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0065)http://theory.stanford.edu/~amitp/GameProgramming/Variations.html -->
<HTML class=gameprog><HEAD><TITLE>Variations of A*</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8"><LINK 
href="index.html" rel=start><LINK href="mailto:amitp@cs.stanford.edu" 
rel=author><LINK href="ImplementationNotes.html" rel=prev><LINK 
href="MovingObstacles.html" rel=next><LINK 
href="http://www-cs-students.stanford.edu/~amitp/favicon.ico" 
rel="shortcut icon"><LINK title=Style href="Variations of A_files/amitp.css" 
rel=stylesheet>
<STYLE type=text/css>TABLE.nav {
	MARGIN-BOTTOM: 2em
}
OL LI {
	LIST-STYLE-TYPE: decimal
}
OL OL LI {
	LIST-STYLE-TYPE: lower-alpha
}
OL OL OL LI {
	LIST-STYLE-TYPE: lower-roman
}
BLOCKQUOTE {
	BORDER-RIGHT: #c0c0b8 1px solid; PADDING-RIGHT: 1ex; BORDER-TOP: #c0c0b8 1px solid; PADDING-LEFT: 1ex; BACKGROUND: #e0e0d8; PADDING-BOTTOM: 1ex; MARGIN-LEFT: 10%; BORDER-LEFT: #c0c0b8 1px solid; MARGIN-RIGHT: 10%; PADDING-TOP: 1ex; BORDER-BOTTOM: #c0c0b8 1px solid
}
DIV.margin {
	BORDER-RIGHT: black 2px solid; PADDING-RIGHT: 1ex; BORDER-TOP: black 1px solid; PADDING-LEFT: 1ex; BACKGROUND: #e0e0d8; FLOAT: right; PADDING-BOTTOM: 1ex; MARGIN: 2ex; BORDER-LEFT: black 1px solid; WIDTH: 30%; PADDING-TOP: 1ex; BORDER-BOTTOM: black 2px solid; TEXT-ALIGN: center
}
DIV.margin HR {
	DISPLAY: none
}
DIV.figure {
	MARGIN-LEFT: 0em; TEXT-ALIGN: center
}
</STYLE>

<META content="MSHTML 6.00.2900.2802" name=GENERATOR></HEAD>
<BODY>
<H1>Variations of A*</H1>
<DIV class=main>
<H2 id=S1>Beam search</H2>
<P>In the main A* loop, the OPEN set stores all the nodes that may need to be 
searched to find a path. The <STRONG>Beam Search</STRONG> is a variation of A* 
that places a limit on the size of the OPEN set. If the set becomes too large, 
the node with the worst chances of giving a good path is dropped. One drawback 
is that you have to keep your set sorted to do this, which limits the kinds of 
data structures you'd choose.</P>
<H2 id=S2>Iterative deepening</H2>
<P>Iterative Deepening is an approach used in many AI algorithms to start with 
an approximate answer, then make it more accurate. The name comes from game tree 
searches, where you look some number of moves ahead (for example, in Chess). You 
can try to deepen the tree by looking ahead more moves. Once your answer doesn't 
change or improve much, you assume that you have a pretty good answer, and it 
won't improve when you try to make it more accurate again. In ID-A*, the "depth" 
is a cutoff for <CODE>f</CODE> values. When the <CODE>f</CODE> value is too 
large, the node won't even be considered (<EM>i.e.,</EM> it won't be added to 
the OPEN set). The first time through you process very few nodes. Each 
subsequent pass, you increase the number of nodes you visit. If you find that 
the path improves, then you continue to increase the cutoff; otherwise, you can 
stop. For more details, read <A 
href="http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html">these lecture 
nodes on ID-A*</A>.</P>
<P>I personally don't see much need for ID-A* for finding paths on game maps. ID 
algorithms tend to increase computation time while reducing memory requirements. 
In map pathfinding, however, the "nodes" are very small―they are simply 
coordinates. I don't see a big win from not storing those nodes.</P>
<H2 id=S3>Dynamic weighting</H2>
<P>With dynamic weighting, you assume that at the beginning of your search, it's 
more important to get (anywhere) quickly; at the end of the search, it's more 
important to get to the goal.</P>
<BLOCKQUOTE><CODE>f(p) = g(p) + w(p) * h(p)</CODE> </BLOCKQUOTE>
<P>There is a weight (<CODE>w &gt;= 1</CODE>) associated with the heuristic. As 
you get closer to the goal, you decrease the weight; this decreases the 
importance of the heuristic, and increases the relative importance of the actual 
cost of the path.</P>
<H2 id=S4>Bandwidth search</H2>
<P>There are two properties about <EM>Bandwidth Search</EM> that some people may 
find useful. This variation assumes that <CODE>h</CODE> is an 
<EM>overestimate</EM>, but that it doesn't overestimate by more than some number 
<CODE>e</CODE>. If this is the case in your search, then the path you get will 
have a cost that doesn't exceed the best path's cost by more than 
<CODE>e</CODE>. Once again, the better you make your heuristic, the better your 
solution will be.</P>
<P>Another property you get is that if you can drop some nodes in the OPEN set. 
Whenever <CODE>h+d</CODE> is greater then the true cost of the path (for some 
<CODE>d</CODE>), you can drop any node that has an <CODE>f</CODE> value that's 
at least <CODE>e+d</CODE> higher than the <CODE>f</CODE> value of the best node 
in OPEN. This is a strange property. You have a "band" of good values for 
<CODE>f</CODE>; everything outside this band can be dropped, because there is a 
guarantee that it will not be on the best path.</P>
<P>Curiously, you can use different heuristics for the two properties, and 
things still work out. You can use one heuristic to guarantee that your path 
isn't too bad, and another one to determine what to drop in the OPEN set.</P>
<H2 id=S5>Bidirectional search</H2>
<P>Instead of searching from the start to the finish, you can start two searches 
in parallel―one from start to finish, and one from finish to start. When they 
meet, you should have a good path.</P>
<P>This sounds like a good idea, but I don't think it'll give you very much. The 
idea behind bidirectional searches is that searching results in a `tree' that 
fans out over the map. A big tree is much worse than two small trees, so it's 
better to have two small search trees. With A*, however, my experiments suggest 
that you <EM>don't</EM> get a tree. You get a path that has nearby map areas 
explored, but it doesn't fan out like Dijkstra's algorithm. In fact, that's what 
makes A* so fast―no matter how long your path is, it doesn't search like crazy, 
unless the path really is crazy. It tends to search only small areas of the map. 
Bidirectional search may be more useful if your map is complex.</P>
<P>The <EM>front-to-front</EM> variation links the two searches together. 
Instead of choosing the best forward-search node―<CODE>g(start,x) + 
h(x,goal)</CODE>―or the best backward-search node―<CODE>g(y,goal) + 
h(start,y)</CODE>―this algorithm chooses a pair of nodes with the best 
<CODE>g(start,x) + h(x,y) + g(y,goal)</CODE>.</P>
<P>The <EM>retargeting</EM> approach abandons simultaneous searches in the 
forward and backward directions. Instead, it performs a forward search for a 
short time, chooses the best forward candidate, and then performs a backward 
search―not to the starting point, but to that candidate. After a while, it 
chooses a best backward candidate and performs a forward search from the best 
forward candidate to the best backward candidate. This process continues until 
the two candidates are the same point.</P>
<H2 id=S6>Dynamic A* and Lifelong Planning A*</H2>
<P>There are variants of A* that allow for changes to the world after the 
initial path is computed. D* is intended for use when you don't have complete 
information. If you don't have all the information, A* can make mistakes; D*'s 
contribution is that it can correct those mistakes without taking much time. 
LPA* is intended for use when the costs are changing. With A*, the path may be 
invalidated by changes to the map; LPA* can re-use previous A* computations to 
produce a new path. <EM>However</EM>, both D* and LPA* require a lot of 
space―essentially you run A* and keep around its internal information 
(<CODE>OPEN/CLOSED</CODE> sets, path tree, <CODE>g</CODE> values), and then when 
the map changes, D* or LPA* will tell you if you need to adjust your path to 
take into account the map changes. For a game with lots of moving units, you 
usually don't want to keep all that information around, so D* and LPA* aren't 
applicable. They were designed for robotics, where there is just one robot―you 
don't need to reuse the memory for some other robot's path. If your game has 
only one or a small number of units, you may want to investigate D* or LPA*.</P>
<UL>
  <LI><A href="http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html">Overview of 
  D*</A> 
  <LI><A href="http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps">D* Paper 1</A> 
  <LI><A href="http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps">D* Paper 2</A> 
  <LI><A href="http://idm-lab.org/project-a.html">Lifelong planning overview</A> 

  <LI><A 
  href="http://csci.mrs.umn.edu/UMMCSciWiki/pub/CSci3903s03/KellysPaper/seminar.pdf">Lifelong 
  planning paper (PDF)</A> </LI></UL></DIV>
<DIV class=footer>
<TABLE class=nav cellSpacing=0 cellPadding=3 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=left width="33%">Back: <A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html" 
      rel=prev>Implementation</A></TD>
    <TD align=middle width="34%">Up: <A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/index.html">Home</A></TD>
    <TD align=right width="33%">Next: <A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html" 
      rel=next>Moving Obstacles</A></TD></TR></TBODY></TABLE>
<ADDRESS>From <A 
href="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game 
Programming Site</A><BR>Last modified: Sat Feb 25 10:23:24 2006<BR>Copyright 
2003, <A href="http://www-cs-students.stanford.edu/~amitp/" rel=copyright>Amit 
J. Patel</A> </ADDRESS></DIV><!-- Start of StatCounter Code -->
<SCRIPT type=text/javascript>
<!-- 
var sc_project=417499; 
var sc_partition=2; 
//-->
</SCRIPT>

<SCRIPT src="Variations of A_files/counter_xhtml.js" 
type=text/javascript></SCRIPT>
<NOSCRIPT>
<DIV class=statcounter><A class=statcounter 
href="http://www.statcounter.com/"><IMG class=statcounter alt="free hit counter" 
src="Variations of A_files/counter.gif"></A></DIV></NOSCRIPT><!-- End of StatCounter Code --></BODY></HTML>
