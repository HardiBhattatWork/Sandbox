<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0061)http://www.sju.edu/~bforoura/courses/lectures/luger/lab3.html -->
<HTML><HEAD><TITLE>CSC 2501: Lecture 3</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="CSC 2501 Lecture 3_files/style.css" type=text/css rel=stylesheet><!------------------------------------------------------>
<META content="MSHTML 6.00.2900.2802" name=GENERATOR></HEAD>
<BODY>
<DIV align=center>
<TABLE height="100%" cellSpacing=3 cellPadding=3 width="85%" bgColor=silver 
border=0>
  <TBODY>
  <TR>
    <TH>
      <TABLE height="100%" cellSpacing=5 cellPadding=5 width="100%" 
      bgColor=white border=0>
        <TBODY>
        <TR>
          <TD>
            <DIV><B class=a>Lecture 3 (Chapter 2)<BR>The Predicate Calculus</B> 
            <BR><BR><BR><IMG height=160 alt=None 
            src="CSC 2501 Lecture 3_files/cover.jpg" width=400 border=0> </DIV><PRE class=a><OL>
<!------------------------------------------------------>
<LI><B class=b>2.0 Introduction</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- The predicate calculus (<B>PredC</B>) is a representation language for AI

-- Advantages of PredC:
   (1) A well-defined <I>formal semantics</I>
   (2) <I>Sound</I> and <I>complete</I> inference rules
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.1.1 The Propositional Calculus (PropC): Symbols &amp; Sentences</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE> 
-- The PropC and PredC are languages used to represent and reason about properties and 
   relationships


-- <B>PropC symbols</B>:
   -- Propositional symbols <B>P, Q, R, S, ...</B>
   -- Truth symbols <B>true, false</B>
   -- Connectives <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0>


-- <B>Propositions</B>:
   -- Statements about the world that may be either true or false
   -- E.g. "The heat is hot," "water is wet," and other pearls of wisdom
   -- Propositions are used to form sentences


-- PropC sentences are well-formed formulas (<B>WFFs</B>) if they satisfy one or more of the 
   following rules:

         (1) Every proposition and truth symbol is a sentence, e.g. <B>true, P, Q, R</B>

         (2) Negation of a sentence is a sentence, e.g. <B><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P, <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>false</B>

         (3) Conjunction of 2 sentences is a sentence, e.g. <B>P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q</B> (two <B>conjuncts</B>)

         (4) Disjunction of 2 sentences is a sentence, e.g. <B>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q</B> (two <B>disjuncts</B>)

         (5) Implication of one sentence to another is a sentence, e.g. <B>P<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>Q</B>

         (6) Equivalence of 2 sentences is a sentence, e.g. <B>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>Q<IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0>R</B>


-- <B>((P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q)<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>R)<IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> R</B> is WFF because:

    P, Q, R are WFF                by Rule (1)
    P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q is a sentence            by Rule (3)
    (P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q)<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>R is a sentence by Rule (5)
    <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P and <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q are sentences              by Rule (2)
    <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q is a sentence                by Rule (4)
    <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>R is a sentence                 by Rule (4)
    (P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q)<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>R<IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>R is a sentence              by Rule (6)

</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.1.2 The Semantics of the Propositional Calculus</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>
-- <I>Semantics</I> refers to meaning of WFFs

-- Because AI programs reason with their representational structures, it's important
   to show the truth of their conclusions; must ensure logical errors are not introduced 
   by the inference rules

-- A proposition symbol corresponds to a statement about the world:
   -- E.g. <B>P</B>: I live in a brown house
   -- E.g. <B>Q</B>: It's raining

-- The truth value assignment to propositional statements is called an <I>interpretation</I>
   which is defined as:
   -- An assertion about a statement's truth in some <I>possible world</I>

   -- A mapping from symbols into the set <B>{T,F}</B>

   -- Note that <B>true</B> and <B>false</B> are a part of the set of WFFs and hence distinct
      from truth values <B>T</B> and <B>F</B>

   -- <B>{P,Q}</B> has 4 different functional mappings into the set <B>{T,F}</B>; these mappings
      are considered 4 different interpretations
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>Propositional Calculus Semantics</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- An interpretation assigns either <B>T</B> or <B>F</B> to each propositional symbol

-- <B>T</B> is always assigned to <B>true</B> and <B>F</B> to <B>false</B>

-- The interpretation or truth value of sentences is determined by the following truth table:
   <DIV align=center>
   <TABLE borderColor=black cellSpacing=0 cellPadding=0 width=500 bgColor=whitesmoke border=1><TBODY><TR bgColor=white><TH>P</TH><TH>Q</TH><TH><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P</TH><TH>P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q</TH><TH>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>Q</TH><TH><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>Q</TH><TH>P<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>Q</TH><TH><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>Q <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> P<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>Q</TH></TR><TR><TH>T</TH><TH>T</TH><TH>F</TH><TH>T</TH><TH>T</TH><TH>T</TH><TH>T</TH><TH>T</TH></TR><TR><TH>T</TH><TH>F</TH><TH>F</TH><TH>F</TH><TH>T</TH><TH>F</TH><TH>F</TH><TH>T</TH></TR><TR><TH>F</TH><TH>T</TH><TH>T</TH><TH>F</TH><TH>T</TH><TH>T</TH><TH>T</TH><TH>T</TH></TR><TR><TH>F</TH><TH>F</TH><TH>T</TH><TH>F</TH><TH>F</TH><TH>T</TH><TH>T</TH><TH>T</TH></TR></TBODY></TABLE>
   </DIV>

-- Important identities:
<!-- ########################### -->
<DIV align=left>
<IMG src="CSC 2501 Lecture 3_files/fig2a.jpg" border=0>
</DIV>
<!-- ########################### -->
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.2 The Predicate Calculus</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- What are the differences between PropC and PredC?

   -- <B>PropC</B>:
      -- Each atomic symbol such as P or Q denotes a proposition and there is no way to 
         access the individual components of that assertion, e.g., <B>P: It rained on Tuesday</B>

      -- Propositions cannot contain variables


   -- <B>PredC</B>:
      -- Allows access to individual components of an assertion, e.g., let's create the predicate 
         <I>weather</I> as follows: <B>weather(rain, tuesday)</B>

      -- Allows expressions to contain variables, e.g., <B>weather(rain, X)</B> 
         where X is any day of the week.
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.2.1 The Syntax of Predicates and Sentences</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- <B> PredC Symbols:</B>

   -- Must begin with an English letter and followed by any sequence of letters, digits (0-9) 
      or underscore(_); they denote objects, properties or relations

   -- Cannot include numbers or arithmetic operators as we will use PredC for that purpose, 
      e.g., <B>zero, one, succ(one), pred(three)</B>, etc.

   -- Four types of PredC <I>terms</I>:
      -- <B>Constants</B>:
         -- Specify specific objects in the world
         -- Always begin with a lowercase letter
         -- E.g. <B>monkey, jo, tree, true, false</B>

      -- <B>Variables</B>:    
         -- Designate a general class of objects
         -- Always begin with an uppercase letter
         -- E.g. <B>Day, Tree, X, Y, Z</B>

      -- <B>Function (expressions)</B>:
         -- Mappings from one set of elements (domain) to another (range)
         -- Always begin with a lowercase letter
         -- E.g. <B>f(X,Y), father(david), price(bananas)</B>

      -- <B>Predicates</B>:
         -- Name relationships between 0 or more objects
         -- Always begin with a lowercase letter
         -- Can take function expressions as their arguments
         -- E.g. <B>likes, equals, on, near, part_of</B>




-- <B> Atomic Sentences:</B>

   -- The most primitive unit of PredC

   -- Predicates of arity n followed by n terms

   -- E.g. <B>likes(george, kate), likes(mary, Y), likes (X,Y, tuesday), on(blockX, blockY), ...</B>

   -- Atomic sentences can be combined using PropC connectives such <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>,<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> and <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0>

   -- Variables can be quantified using the <I>universal (<IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>)</I> or <I>existential (<IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>)</I> qualifiers

   -- E.g. <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>Y friends(Y, peter), <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X likes(X, ice_cream)</B>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>PredC Sentences</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- PredC sentences are well-formed sentences (<B>WFSs</B>) if they satisfy one or more of the 
   following rules:

         (1) Negation of a sentence is a sentence, <B><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>s</B>

         (2) Conjunction of 2 sentences is a sentence, <B>s1<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>s2</B>

         (3) Disjunction of 2 sentences is a sentence, <B>s1<IMG src="CSC 2501 Lecture 3_files/or.gif" border=0><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>s2</B>

         (4) Implication of one sentence to another is a sentence, <B>s1<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>s2</B>

         (5) Equivalence of 2 sentences is a sentence, <B>s1<IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0>s2</B>

         (6) If X is a variable and s a sentence, <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X s</B> is a sentence

         (7) If X is a variable and s a sentence, <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X s</B> is a sentence


-- Examples of PredC WFSs assuming function symbols <B>times, plus</B> and predicate symbols 
   <B>equal, foo</B>:

   -- <B>plus(two, three)</B> is a function and not an atomic sentence

   -- <B>equal(plus(two,three), five)</B> is an atomic sentence

   -- <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X foo(X, two, plus(two,three)) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> equal(plus(two,three), five)</B> since both
      conjuncts are WFSs




-- A recursive algorithm that takes as argument a candidate expression and returns <B>success</B> 
   if the expression is a WFS:
<!-- ########################### -->
<DIV align=left>
<IMG src="CSC 2501 Lecture 3_files/fig2b.jpg" border=0>
</DIV>
<!-- ########################### -->



-- An example:
   <B>
      mother(eve,abel)
      mother(eve,cain)
      father(adam,abel)
      father(adam,cain)

      <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Y father(X,Y) <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> mother(X,Y) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> parent(X,Y)
      <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Y <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Z parent(X,Y) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> parent(X,Z) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> sibling(Y,Z)
   </B>


-- Evaluate the following sentences:
   <B>
      mother(eve,X)
      father(Y,Z)
      sibling(adam,W)
      mother(cain,M)
   </B>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>Can Prolog handle the above example?</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- <B>Prolog</B> is the perfect AI language for drawing conclusions given a set of PredC expressions:
       <XMP>       //*** test.pl
       mother(eve,abel).
       mother(eve,cain).
       father(adam,abel).
       father(adam,cain).

       parent(X,Y) :- father(X,Y); 
                            mother(X,Y).

       sibling(Y,Z) :- parent(X,Y), 
                            parent(X,Z), 
                            Y \= Z.





       Script started on Wed Jul 24 18:41:12 2003

       maxwell% bp
       B-Prolog Version 3.0 (C) Neng-Fa Zhou 1994-1998.
       | ?- ['test.pl'].

       consulting....test.pl
       yes

       | ?- mother(eve, Who).
       Who = abel?;
       Who = cain?;


       | ?- father(eve, W).
       no


       | ?- sibling(X,Y).
       X = abel
       Y = cain?;

       X = cain
       Y = abel?;

       X = abel
       Y = cain?;

       X = cain
       Y = abel?;
       no


       | ?- halt.
       maxwell%

       script done on Wed Jul 24 18:43:01 2003
       </XMP>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.2.2 A Semantics for the Predicate Calculus</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- PredC semantics provides a formal basis for determining truth values of WFSs

-- Truth of relationships depends on the truth values of their constituent constants,
   variables, and functions expressions

-- Need to define two things:
   (1) Interpretation
   (2) Rules for determining truth values



-- <B>(1) An interpretation over a nonemtpy domain set D</B>:

   -- An assignment of the entities of D to constants, variables, functions and predicates
      of a PredC sentence

   -- Each constant is assigned an element from D

   -- Each variable is assigned a nonempty subset of D

   -- Each function f<SUP>m</SUP> has m arguments of D and defines a mapping from D<SUP>m</SUP> into D

   -- Each predicate p<SUP>n</SUP> has n arguments of D and defines a mapping from D<SUP>n</SUP> into {T,F}




-- <B>(2) Given an expression E and an interpretation I for E over D, the truth value of E is 
   determined by the following rules:</B>
   <DIV align=center>
   <TABLE borderColor=black cellSpacing=0 cellPadding=0 width=500 bgColor=whitesmoke border=1><TBODY><TR bgColor=whitesmoke><TH>Entity</TH><TH>Value</TH></TR><TR bgColor=white><TH>Constant</TH><TH>An element from D assigned by I</TH></TR><TR bgColor=white><TH>Variable</TH><TH>A subset of D assigned by I</TH></TR><TR bgColor=white><TH>Function</TH><TH>An element of D obtained by evaluating function parameters over I</TH></TR><TR bgColor=white><TH>true</TH><TH>T</TH></TR><TR bgColor=white><TH>false</TH><TH>F</TH></TR><TR bgColor=white><TH>Atomic sentence</TH><TH>T or F based on I</TH></TR><TR bgColor=white><TH>Expressions involving <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>, <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0>, <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>, <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>, <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0></TH><TH>Same as for PropC</TH></TR><TR bgColor=white><TH><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X S</TH><TH>T if S is T for all assignments to X under I; F otherwise</TH></TR><TR bgColor=white><TH><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X S</TH><TH>T if S is T for at least one assignment to X under I; F otherwise</TH></TR></TBODY></TABLE>
   </DIV>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>More on PredC Quantifiers</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- Given the expression <B>likes(goerge,X)</B>:
   -- Variable X is a place holder standing for all constants that might appear

   -- X may be replaced by any other variable, say, XXX; hence the term the <I>dummy</I> variable

-- PredC variables are <I>quantified</I> in one of 2 ways:
   -- <B>Universally</B>
   -- <B>Existentially</B>

-- Two types of expressions:
   -- <B>free</B>:  None of involved variables are within the scope of any quantifiers
   -- <B>closed</B>: All variables are quantified

-- A <B>ground expression</B>: has no variables at all

-- All PredC variables <B>must be quantified</B>

-- <B>Scope</B> of quantification is denoted by parentheses. Thus, in

       <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X (p(X) <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> q(Y) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> r(X))</B>

   X is universally quantified by both p(X) and r(X).



-- <B>Evaluating Universally Quantified Expressions</B>:

   -- Evaluation of <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X likes(goerge,X)</B> requires examining all 
      values of X, which range over the set of all human beings

   -- The algorithm for testing infinite values of X will <B>never halt</B>. PredC, therefore,
      is <B>undecidable</B>

   -- Note that PropC does not use variables, thus expressions have finite number of
      truth value assignments



-- <B>Evaluating Existentially Quantified Expressions</B>:

   -- This may not be any easier than the problem of evaluating universally quantified 
      variables

   -- Evaluation of <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X likes(goerge,X)</B> may <B>never halt</B>
      if expression is false under all substitutions.



-- Important <B>Identities</B>:
      
      (1) <B><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X p(X) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>p(X)</B>
      (2) <B><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X p(X) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>p(X)</B>

      (3) <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X p(X) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>Y p(Y)</B>
      (4) <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X q(X) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Y q(Y)</B>

      (5) <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X (p(X) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> q(X)) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X p(X) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Y q(Y)</B>
      (6) <B><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X (p(X) <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> q(X)) <IMG src="CSC 2501 Lecture 3_files/equiv.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X p(X) <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>Y q(Y)</B>



-- FOPC <B>does not allow</B> quantification of functions and predicates but higher order calculi
   such as the second order predicate calculus (SOPC) does.



-- A major challenge of AI is to find an efficient means to convert English sentences into
   FOPC expressions and vice versa:
<!-- ########################### -->
<DIV align=center>
<IMG src="CSC 2501 Lecture 3_files/fig2c.jpg" border=0>
</DIV>
<!-- ########################### -->
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.2.3 A "Blocks World" Example</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- We would like to model the following blocks world in order to design, say, a control
   algorithm for a robot arm
<!-- ########################### -->
<DIV align=center>
<IMG src="CSC 2501 Lecture 3_files/fig2_3.jpg" border=0>
</DIV>
<!-- ########################### -->
-- Assume the computer has knowledge of locations of blocks and the arm is able to keep
   track of these locations

-- Note that our PredC world:
   (1) Needs an interpretation
   (2) Is <B>declarative</B>, i.e., there is no timing or order for considering expressions



-- <B>Picking up and Clearing Blocks</B>:

   -- To pick up a block and place on top of another block, both blocks must be clear

   -- In above, <B>block a</B> is not clear but the arm can make it so by moving <B>block c</B>

   -- Let's assume robot does move <B>block c</B> and updates its knowledge base deleting the 
      assertion <B>on(c,a)</B> 

   -- The program must now be able to <B>infer</B> that <B>block a</B> is clear

   -- The following rule describes when a block is clear 
            <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X (<IMG src="CSC 2501 Lecture 3_files/not.gif" border=0><IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>Y on(Y,X) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> clear(X))</B>

   
-- What is the value of <B>clear(d)</B>?
      
   -- Not true because if X is given the value d, substituting b for Y will make
      the statement false; hence, to make <B>clear(d)</B> true, we must first execute
      <B>clear(b)</B>



-- <B>Stacking Blocks</B>:

   -- We want to stack X on Y

   -- Operations:
      <B>empty_hand, clear X, clear Y, pick_up X, put_down X on Y</B>

      <B><IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>Y ((hand_empty <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> clear(X) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> clear(Y) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> pick_up(X) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> put_down(X,Y) 
      <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> stack(X,Y))</B>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>2.3.1 Inference Rules</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- <B>Logical inference</B>:

   -- The ability to infer new correct expressions (knowledge) from a set of true assertions

   -- The new assertions are correct in that they are <B>consistent</B> with  the original
      set of assertions



-- A few points:

   -- An interpretation I that makes a sentence true is said to <B>satisfy</B> that sentence

   -- An expression X <B>logically follows</B> from a set of expressions S if every I that 
      satisfies S also satisfies X 
     
   -- <B>"X Logically follows S"</B> does not mean X is deducible from S; rather, it means that
      X is true for every interpretation that satisfies S

   -- Since predicate systems can have an infinite number of interpretations, inference rules
      provide a computationally feasible way to determine when an expression is valid



-- A few definitions:
   <DIV align=center>
   <TABLE borderColor=black cellSpacing=0 cellPadding=0 width=500 bgColor=whitesmoke border=1><TBODY><TR bgColor=whitesmoke><TH>Term</TH><TH>Meaning</TH></TR><TR bgColor=white><TH>I Satisfies X</TH><TH>X has the value T under I</TH></TR><TR bgColor=white><TH>I is a Model of X</TH><TH>I satisfies X for all variable assignments</TH></TR><TR bgColor=white><TH>X is Satisfiable</TH><TH>There is an I and variable assignment that satisfy X</TH></TR><TR bgColor=white><TH>E is Inconsistent</TH><TH>Expression E is unsatisfiable <BR>E.g. <IMG src="CSC 2501 Lecture 3_files/exists.gif" border=0>X (p(X) <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>p(X)) </TH></TR><TR bgColor=white><TH>X is Valid</TH><TH>X is T for all possible I <BR>E.g. <IMG src="CSC 2501 Lecture 3_files/forall.gif" border=0>X (p(X) <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>p(X)) </TH></TR></TBODY></TABLE>
   </DIV>


-- What's <B>proof procedure</B>?

   -- A combination of an inference rule and an algorithm for rule application
   -- Applied to a set of logical expressions to generate new sentences

-- An inference rule is said to be:
  -- <B>Sound</B>: if every predicate expression produced by the rule form a set S
     logically follows S

  -- <B>Complete</B>: if the rule can infer every expression that logically follows 
     from S



-- Inference rules to live by [sic]:
   <DIV align=center>
   <TABLE borderColor=black cellSpacing=0 cellPadding=5 width=500 bgColor=whitesmoke border=1><TBODY><TR bgColor=whitesmoke><TH>Rule</TH><TH>Definition</TH></TR><TR bgColor=white><TH>Modus Ponens (MP)</TH><TD><B>P<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>Q<BR>P<BR><IMG src="CSC 2501 Lecture 3_files/hence.gif" border=0> Q </B></TD></TR></TR><TR bgColor=white><TH>Modus Tollens (MT)</TH><TD><B>P<IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0>Q<BR><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q<BR><IMG src="CSC 2501 Lecture 3_files/hence.gif" border=0> <IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>P </B></TD></TR><TR bgColor=white><TH>Conjunction (CONJ)</TH><TD><B>P<BR>Q<BR><IMG src="CSC 2501 Lecture 3_files/hence.gif" border=0> P <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> Q </B></TD></TR><TR bgColor=white><TH>Resolution Rule (RR)</TH><TD><B>P <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> Q<BR><IMG src="CSC 2501 Lecture 3_files/not.gif" border=0>Q <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> R<BR><IMG src="CSC 2501 Lecture 3_files/hence.gif" border=0> P <IMG src="CSC 2501 Lecture 3_files/or.gif" border=0> R </B></TD></TR></TBODY></TABLE>
   </DIV>
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>An Example of Proof Procedure</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- Given <B>(P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> R, (S<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>T) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> Q, S, T, P</B>, prove <B>R</B>


-- Proof:
   <DIV align=center>
   <TABLE borderColor=black cellSpacing=0 cellPadding=0 width=500 bgColor=whitesmoke border=0><TBODY><TR bgColor=silver><TH>Step</TH><TH>Result</TH><TH>Justification</TH></TR><TR bgColor=white><TH colSpan=3>&nbsp;</TH></TR><TR bgColor=whitesmoke><TH>1</TH><TH>S</TH><TH>Given axiom</TH></TR><TR bgColor=white><TH>2</TH><TH>T</TH><TH>Given axiom</TH></TR><TR bgColor=whitesmoke><TH>3</TH><TH>S<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>T</TH><TH>CONJ(1,2)</TH></TR><TR bgColor=white><TH>4</TH><TH>(S<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>T) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> Q</TH><TH>Given axiom</TH></TR><TR bgColor=whitesmoke><TH>5</TH><TH>Q</TH><TH>MP(3,4)</TH></TR><TR bgColor=white><TH>6</TH><TH>P</TH><TH>Axiom</TH></TR><TR bgColor=whitesmoke><TH>7</TH><TH>P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q</TH><TH>CONJ(5,6)</TH></TR><TR bgColor=white><TH>8</TH><TH>(P<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Q) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> R</TH><TH>Axiom</TH></TR><TR bgColor=whitesmoke><TH>9</TH><TH>R</TH><TH>MP(7,8)</TH></TR></TBODY></TABLE>
   </DIV>
</PRE></TD></TR></TBODY></TABLE>


<!------------------------------------------------------>
<LI><B class=b>Automated Theorem Proving in Lisp</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE>-- Main points to remember:

   -- Proper axioms are of the form:
      <B>Rule R: (P1<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P2<IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>Pn) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> Q</B>

   -- <B>Fact:</B> 
      A rule without an antecedent

   -- <B>Goal reduction</B>: 
      A method for proving a conjunction of propositional variables given axioms in the 
      form shown above 

   -- Assuming we have a goal Q and the rule R, if we can prove 

         (P<SUB>1</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>2</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>n</SUB>)

      then we can prove Q; hence, proving Q is reduced to proving (P<SUB>1</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>2</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>n</SUB>)
 



-- Proving <B>(P<SUB>1</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>2</SUB><IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0>P<SUB>n</SUB>)</B>

       If (n=0), then DONE 
       If (n&gt;0), then select some k between 1 and n 
       If P<SUB>k</SUB> is a fact, then prove (P<SUB>1</SUB> <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> P<SUB>k-1</SUB> <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> P<SUB>k+1</SUB> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> P<SUB>n</SUB>) 
       If P<SUB>k</SUB> is not a fact, find some rule of the form (Q<SUB>1</SUB> <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> ... <IMG src="CSC 2501 Lecture 3_files/and.gif" border=0> Q<SUB>m</SUB>) <IMG src="CSC 2501 Lecture 3_files/imply.gif" border=0> P<SUB>k</SUB> 
       else report error 




-- <B>A Lisp Example:</B>

   (defun <B>conseq</B>  (rule) (first rule))

   (defun <B>anteced</B> (rule) (rest (rest rule)))

   (defun <B>theorem</B> (conjuncts rules)
     (aux-theorem conjuncts rules rules))

   (defun <B>aux-theorem</B> (conjuncts untried rules)
     (cond 
         ((null conjuncts) t)
         ((null untried)   nil)
         ((and (eq (first conjuncts) (conseq (first untried)))
               (<B>aux-theorem</B> 
		   (append (anteced (first untried)) (rest conjuncts)) 
		            rules rules)) 			t)

         (t 		(<B>aux-theorem</B> conjuncts (rest untried) rules))
     )
   )



   (<B>theorem</B> '(R) '((R IF P Q) (Q IF S T) (P) (S) (T)))
   T

   (<B>theorem</B> '(p) '((P if Q) (Q if P) (Q)))
   error: argument stack overflow
</PRE></TD></TR></TBODY></TABLE>

<!------------------------------------------------------>
<LI><B class=b>An Exercise</B>

<TABLE width="90%" bgColor=white border=1><TBODY><TR><TD><PRE><I>
Either Heather attended the meeting or Heather was not invited. If the boss wanted 
Heather at the meeting, then she was invited. Heather did not attend the meeting. If 
the boss did not want Heather there, and the boss did not invite her there, then she 
is going to be fired.</I>


Prove <B>Heather is going to be fired</B>.
</PRE></TD></TR></TBODY></TABLE>

	
<!------------------------------------------------------>
</LI></OL></PRE></TD></TR></TBODY></TABLE></TH></TR></TBODY></TABLE></DIV></BODY></HTML>
