<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0050)http://theory.stanford.edu/~amitp/GameProgramming/ -->
<HTML class=gameprog><HEAD><TITLE>Amit's A* Pages</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8"><LINK 
href="index.html" rel=start><LINK href="mailto:amitp@cs.stanford.edu" 
rel=author><LINK href="AStarComparison.html" rel=next><LINK 
href="http://www-cs-students.stanford.edu/~amitp/favicon.ico" 
rel="shortcut icon"><LINK title=Style href="Amit's A Pages_files/amitp.css" 
rel=stylesheet>
<STYLE type=text/css>TABLE.nav {
	MARGIN-BOTTOM: 2em
}
OL LI {
	LIST-STYLE-TYPE: decimal
}
OL OL LI {
	LIST-STYLE-TYPE: lower-alpha
}
OL OL OL LI {
	LIST-STYLE-TYPE: lower-roman
}
BLOCKQUOTE {
	BORDER-RIGHT: #c0c0b8 1px solid; PADDING-RIGHT: 1ex; BORDER-TOP: #c0c0b8 1px solid; PADDING-LEFT: 1ex; BACKGROUND: #e0e0d8; PADDING-BOTTOM: 1ex; MARGIN-LEFT: 10%; BORDER-LEFT: #c0c0b8 1px solid; MARGIN-RIGHT: 10%; PADDING-TOP: 1ex; BORDER-BOTTOM: #c0c0b8 1px solid
}
DIV.margin {
	BORDER-RIGHT: black 2px solid; PADDING-RIGHT: 1ex; BORDER-TOP: black 1px solid; PADDING-LEFT: 1ex; BACKGROUND: #e0e0d8; FLOAT: right; PADDING-BOTTOM: 1ex; MARGIN: 2ex; BORDER-LEFT: black 1px solid; WIDTH: 30%; PADDING-TOP: 1ex; BORDER-BOTTOM: black 2px solid; TEXT-ALIGN: center
}
DIV.margin HR {
	DISPLAY: none
}
DIV.figure {
	MARGIN-LEFT: 0em; TEXT-ALIGN: center
}
</STYLE>

<META content="MSHTML 6.00.2900.2802" name=GENERATOR></HEAD>
<BODY>
<H1>Amit's Thoughts on Path-Finding and A-Star</H1>
<DIV class=main>
<P>The problem we're trying to solve is to get a game object from the starting 
point to a goal. <EM>Pathfinding</EM> addresses the problem of finding a good 
path from the starting point to the goal―avoiding obstacles, avoiding enemies, 
and minimizing costs (fuel, time, distance, equipment, money, etc.). 
<EM>Movement</EM> addresses the problem of taking a path and moving along it. 
It's possible to spend your efforts on only one of these. At one extreme, a 
sophisticated pathfinder coupled with a trivial movement algorithm would find a 
path when the object begins to move and the object would follow that path, 
oblivious to everything else. At the other extreme, a movement-only system would 
not look ahead to find a path (instead, the initial "path" would be a straight 
line), but instead take one step at a time, considering the local environment at 
every point. Best results are achieved by using both pathfinding and movement 
algorithms.</P>
<H2 id=S1>Pathfinding</H2>
<OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html" 
  rel=section>Introduction</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html#S1" 
    rel=section>Algorithms</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html#S2" 
    rel=section>Dijkstra's Algorithm and Best-First-Search</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html#S3" 
    rel=section>The A* Algorithm</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" 
  rel=section>Heuristics</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S1" 
    rel=section>A*'s Use of the Heuristic</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S2" 
    rel=section>Speed or accuracy?</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S3" 
    rel=section>Scale</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S4" 
    rel=section>Exact heuristics</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S5" 
      rel=section>Precomputed exact heuristic</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S6" 
      rel=section>Linear exact heuristic</A> </LI></OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S7" 
    rel=section>Heuristics for grid maps</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S8" 
      rel=section>Manhattan distance</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S9" 
      rel=section>Diagonal distance</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S10" 
      rel=section>Euclidean distance</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S11" 
      rel=section>Euclidean distance, squared</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S12" 
      rel=section>Breaking ties</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S13" 
      rel=section>Searching for an area</A> </LI></OL></LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html" 
  rel=section>Implementation notes</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S1" 
    rel=section>Sketch</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S2" 
    rel=section>Source code</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S3" 
    rel=section>Set representation</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S4" 
      rel=section>Unsorted arrays or linked lists</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S5" 
      rel=section>Sorted arrays</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S6" 
      rel=section>Sorted linked lists</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S7" 
      rel=section>Sorted skip lists</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S8" 
      rel=section>Indexed arrays</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S9" 
      rel=section>Hash tables</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S10" 
      rel=section>Binary heaps</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S11" 
      rel=section>Splay trees</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S12" 
      rel=section>HOT queues</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S13" 
      rel=section>Comparison</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S14" 
      rel=section>Hybrid representations</A> </LI></OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S15" 
    rel=section>Interaction with the game loop</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S16" 
      rel=section>Early exit</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S17" 
      rel=section>Interruptible algorithm</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S18" 
      rel=section>Group movement</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#S19" 
      rel=section>Refinement</A> </LI></OL></LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html" 
  rel=section>Variations of A*</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S1" 
    rel=section>Beam search</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S2" 
    rel=section>Iterative deepening</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S3" 
    rel=section>Dynamic weighting</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S4" 
    rel=section>Bandwidth search</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S5" 
    rel=section>Bidirectional search</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Variations.html#S6" 
    rel=section>Dynamic A* and Lifelong Planning A*</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html" 
  rel=section>Dealing with moving obstacles</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html#S1" 
    rel=section>Recalculating paths</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html#S2" 
    rel=section>Path splicing</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html#S3" 
    rel=section>Watching for map changes</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html#S4" 
    rel=section>Predicting obstacle movement</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html" 
  rel=section>Space used by precalculated paths</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S1" 
    rel=section>Locations vs. directions</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S2" 
    rel=section>Path compression</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S3" 
      rel=section>Location storage</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S4" 
      rel=section>Direction storage</A> </LI></OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S5" 
    rel=section>Computed waypoints</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S6" 
    rel=section>Limited path length</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html#S7" 
    rel=section>Summary</A> </LI></OL></LI></OL>
<H2 id=S2>Other topics</H2>
<P>There are many other topics related to pathfinding.</P>
<OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html" 
  rel=section>Map representations</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S1" 
    rel=section>Grid</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S2" 
    rel=section>Polygonal maps</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S3" 
    rel=section>Flat</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S4" 
    rel=section>Hierarchical</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S5" 
    rel=section>Wraparound maps</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S6" 
    rel=section>Road maps</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S7" 
    rel=section>Duals</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S8" 
    rel=section>Skip links</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S9" 
    rel=section>Waypoints</A> </LI></OL>
  <LI><A href="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html" 
  rel=section>Long and short term goals</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html#S1" 
    rel=section>Unit movement</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html#S2" 
    rel=section>Behavior flags or stacks</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html#S3" 
    rel=section>Waiting for movement</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html#S4" 
    rel=section>Coordinated movement</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html" 
  rel=section>Movement costs for pathfinders</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S1" 
    rel=section>Altitude</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S2" 
      rel=section>Moving uphill</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S3" 
      rel=section>Moving up- or downhill</A> </LI></OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S4" 
    rel=section>Terrain</A> 
    <OL>
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S5" 
      rel=section>Forests, mountains, and hills</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S6" 
      rel=section>Roads</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S7" 
      rel=section>Walls or other barriers</A> 
      <LI><A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S8" 
      rel=section>Sloped Land</A> </LI></OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S9" 
    rel=section>Enemies and friendly units</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S10" 
    rel=section>Marked beacons</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html#S11" 
    rel=section>Fuel consumption</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html" 
  rel=section>User experience with shortest paths</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html#S1" 
    rel=section>Dumb movement</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html#S2" 
    rel=section>Smart movement</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html#S3" 
    rel=section>Multithreading</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html#S4" 
    rel=section>Multiple units</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html#S5" 
    rel=section>Multiple waypoints</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html" 
  rel=section>Applications</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html#S1" 
    rel=section>Exploration</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html#S2" 
    rel=section>Spying</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html#S3" 
    rel=section>Road building</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html#S4" 
    rel=section>Terrain analysis</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/Applications.html#S5" 
    rel=section>City building</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/AITechniques.html" 
  rel=section>AI techniques</A> 
  <OL>
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AITechniques.html#S1" 
    rel=section>Neural Networks</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AITechniques.html#S2" 
    rel=section>Genetic Algorithms</A> 
    <LI><A 
    href="http://theory.stanford.edu/~amitp/GameProgramming/AITechniques.html#S3" 
    rel=section>Reinforcement Learning</A> </LI></OL>
  <LI><A 
  href="http://theory.stanford.edu/~amitp/GameProgramming/References.html" 
  rel=section>References</A> </LI></OL></DIV>
<DIV class=footer>
<TABLE class=nav cellSpacing=0 cellPadding=3 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=left width="33%"></TD>
    <TD align=middle width="34%"></TD>
    <TD align=right width="33%">Next: <A 
      href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html" 
      rel=next>Introduction</A></TD></TR></TBODY></TABLE>
<ADDRESS>From <A 
href="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game 
Programming Site</A><BR>Last modified: Sat Feb 25 10:23:23 2006<BR>Copyright 
2003, <A href="http://www-cs-students.stanford.edu/~amitp/" rel=copyright>Amit 
J. Patel</A> </ADDRESS></DIV><!-- Start of StatCounter Code -->
<SCRIPT type=text/javascript>
<!-- 
var sc_project=417499; 
var sc_partition=2; 
//-->
</SCRIPT>

<SCRIPT src="Amit's A Pages_files/counter_xhtml.js" 
type=text/javascript></SCRIPT>
<NOSCRIPT>
<DIV class=statcounter><A class=statcounter 
href="http://www.statcounter.com/"><IMG class=statcounter alt="free hit counter" 
src="Amit's A Pages_files/counter.gif"></A></DIV></NOSCRIPT><!-- End of StatCounter Code --></BODY></HTML>
